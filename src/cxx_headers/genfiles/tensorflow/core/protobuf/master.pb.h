// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/protobuf/master.proto

#ifndef PROTOBUF_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto_INCLUDED
#define PROTOBUF_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto_INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "tensorflow/core/framework/device_attributes.pb.h"
#include "tensorflow/core/framework/graph.pb.h"
#include "tensorflow/core/lib/core/error_codes.pb.h"
#include "tensorflow/core/protobuf/config.pb.h"
#include "tensorflow/core/protobuf/named_tensor.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[14];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsCreateSessionRequestImpl();
void InitDefaultsCreateSessionRequest();
void InitDefaultsCreateSessionResponseImpl();
void InitDefaultsCreateSessionResponse();
void InitDefaultsExtendSessionRequestImpl();
void InitDefaultsExtendSessionRequest();
void InitDefaultsExtendSessionResponseImpl();
void InitDefaultsExtendSessionResponse();
void InitDefaultsRunStepRequestImpl();
void InitDefaultsRunStepRequest();
void InitDefaultsRunStepResponseImpl();
void InitDefaultsRunStepResponse();
void InitDefaultsPartialRunSetupRequestImpl();
void InitDefaultsPartialRunSetupRequest();
void InitDefaultsPartialRunSetupResponseImpl();
void InitDefaultsPartialRunSetupResponse();
void InitDefaultsCloseSessionRequestImpl();
void InitDefaultsCloseSessionRequest();
void InitDefaultsCloseSessionResponseImpl();
void InitDefaultsCloseSessionResponse();
void InitDefaultsResetRequestImpl();
void InitDefaultsResetRequest();
void InitDefaultsResetResponseImpl();
void InitDefaultsResetResponse();
void InitDefaultsListDevicesRequestImpl();
void InitDefaultsListDevicesRequest();
void InitDefaultsListDevicesResponseImpl();
void InitDefaultsListDevicesResponse();
inline void InitDefaults() {
  InitDefaultsCreateSessionRequest();
  InitDefaultsCreateSessionResponse();
  InitDefaultsExtendSessionRequest();
  InitDefaultsExtendSessionResponse();
  InitDefaultsRunStepRequest();
  InitDefaultsRunStepResponse();
  InitDefaultsPartialRunSetupRequest();
  InitDefaultsPartialRunSetupResponse();
  InitDefaultsCloseSessionRequest();
  InitDefaultsCloseSessionResponse();
  InitDefaultsResetRequest();
  InitDefaultsResetResponse();
  InitDefaultsListDevicesRequest();
  InitDefaultsListDevicesResponse();
}
}  // namespace protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto
namespace tensorflow {
class CloseSessionRequest;
class CloseSessionRequestDefaultTypeInternal;
extern CloseSessionRequestDefaultTypeInternal _CloseSessionRequest_default_instance_;
class CloseSessionResponse;
class CloseSessionResponseDefaultTypeInternal;
extern CloseSessionResponseDefaultTypeInternal _CloseSessionResponse_default_instance_;
class CreateSessionRequest;
class CreateSessionRequestDefaultTypeInternal;
extern CreateSessionRequestDefaultTypeInternal _CreateSessionRequest_default_instance_;
class CreateSessionResponse;
class CreateSessionResponseDefaultTypeInternal;
extern CreateSessionResponseDefaultTypeInternal _CreateSessionResponse_default_instance_;
class ExtendSessionRequest;
class ExtendSessionRequestDefaultTypeInternal;
extern ExtendSessionRequestDefaultTypeInternal _ExtendSessionRequest_default_instance_;
class ExtendSessionResponse;
class ExtendSessionResponseDefaultTypeInternal;
extern ExtendSessionResponseDefaultTypeInternal _ExtendSessionResponse_default_instance_;
class ListDevicesRequest;
class ListDevicesRequestDefaultTypeInternal;
extern ListDevicesRequestDefaultTypeInternal _ListDevicesRequest_default_instance_;
class ListDevicesResponse;
class ListDevicesResponseDefaultTypeInternal;
extern ListDevicesResponseDefaultTypeInternal _ListDevicesResponse_default_instance_;
class PartialRunSetupRequest;
class PartialRunSetupRequestDefaultTypeInternal;
extern PartialRunSetupRequestDefaultTypeInternal _PartialRunSetupRequest_default_instance_;
class PartialRunSetupResponse;
class PartialRunSetupResponseDefaultTypeInternal;
extern PartialRunSetupResponseDefaultTypeInternal _PartialRunSetupResponse_default_instance_;
class ResetRequest;
class ResetRequestDefaultTypeInternal;
extern ResetRequestDefaultTypeInternal _ResetRequest_default_instance_;
class ResetResponse;
class ResetResponseDefaultTypeInternal;
extern ResetResponseDefaultTypeInternal _ResetResponse_default_instance_;
class RunStepRequest;
class RunStepRequestDefaultTypeInternal;
extern RunStepRequestDefaultTypeInternal _RunStepRequest_default_instance_;
class RunStepResponse;
class RunStepResponseDefaultTypeInternal;
extern RunStepResponseDefaultTypeInternal _RunStepResponse_default_instance_;
}  // namespace tensorflow
namespace google {
namespace protobuf {
template<> ::tensorflow::CloseSessionRequest* Arena::CreateMessage< ::tensorflow::CloseSessionRequest>(Arena*);
template<> ::tensorflow::CloseSessionResponse* Arena::CreateMessage< ::tensorflow::CloseSessionResponse>(Arena*);
template<> ::tensorflow::CreateSessionRequest* Arena::CreateMessage< ::tensorflow::CreateSessionRequest>(Arena*);
template<> ::tensorflow::CreateSessionResponse* Arena::CreateMessage< ::tensorflow::CreateSessionResponse>(Arena*);
template<> ::tensorflow::ExtendSessionRequest* Arena::CreateMessage< ::tensorflow::ExtendSessionRequest>(Arena*);
template<> ::tensorflow::ExtendSessionResponse* Arena::CreateMessage< ::tensorflow::ExtendSessionResponse>(Arena*);
template<> ::tensorflow::ListDevicesRequest* Arena::CreateMessage< ::tensorflow::ListDevicesRequest>(Arena*);
template<> ::tensorflow::ListDevicesResponse* Arena::CreateMessage< ::tensorflow::ListDevicesResponse>(Arena*);
template<> ::tensorflow::PartialRunSetupRequest* Arena::CreateMessage< ::tensorflow::PartialRunSetupRequest>(Arena*);
template<> ::tensorflow::PartialRunSetupResponse* Arena::CreateMessage< ::tensorflow::PartialRunSetupResponse>(Arena*);
template<> ::tensorflow::ResetRequest* Arena::CreateMessage< ::tensorflow::ResetRequest>(Arena*);
template<> ::tensorflow::ResetResponse* Arena::CreateMessage< ::tensorflow::ResetResponse>(Arena*);
template<> ::tensorflow::RunStepRequest* Arena::CreateMessage< ::tensorflow::RunStepRequest>(Arena*);
template<> ::tensorflow::RunStepResponse* Arena::CreateMessage< ::tensorflow::RunStepResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace tensorflow {

// ===================================================================

class CreateSessionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.CreateSessionRequest) */ {
 public:
  CreateSessionRequest();
  virtual ~CreateSessionRequest();

  CreateSessionRequest(const CreateSessionRequest& from);

  inline CreateSessionRequest& operator=(const CreateSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateSessionRequest(CreateSessionRequest&& from) noexcept
    : CreateSessionRequest() {
    *this = ::std::move(from);
  }

  inline CreateSessionRequest& operator=(CreateSessionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateSessionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateSessionRequest* internal_default_instance() {
    return reinterpret_cast<const CreateSessionRequest*>(
               &_CreateSessionRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(CreateSessionRequest* other);
  void Swap(CreateSessionRequest* other);
  friend void swap(CreateSessionRequest& a, CreateSessionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateSessionRequest* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::CreateMessage<CreateSessionRequest>(NULL);
  }

  CreateSessionRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::CreateMessage<CreateSessionRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateSessionRequest& from);
  void MergeFrom(const CreateSessionRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateSessionRequest* other);
  protected:
  explicit CreateSessionRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string target = 3;
  void clear_target();
  static const int kTargetFieldNumber = 3;
  const ::std::string& target() const;
  void set_target(const ::std::string& value);
  #if LANG_CXX11
  void set_target(::std::string&& value);
  #endif
  void set_target(const char* value);
  void set_target(const char* value, size_t size);
  ::std::string* mutable_target();
  ::std::string* release_target();
  void set_allocated_target(::std::string* target);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_target();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_target(
      ::std::string* target);

  // .tensorflow.GraphDef graph_def = 1;
  bool has_graph_def() const;
  void clear_graph_def();
  static const int kGraphDefFieldNumber = 1;
  const ::tensorflow::GraphDef& graph_def() const;
  ::tensorflow::GraphDef* release_graph_def();
  ::tensorflow::GraphDef* mutable_graph_def();
  void set_allocated_graph_def(::tensorflow::GraphDef* graph_def);
  void unsafe_arena_set_allocated_graph_def(
      ::tensorflow::GraphDef* graph_def);
  ::tensorflow::GraphDef* unsafe_arena_release_graph_def();

  // .tensorflow.ConfigProto config = 2;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 2;
  const ::tensorflow::ConfigProto& config() const;
  ::tensorflow::ConfigProto* release_config();
  ::tensorflow::ConfigProto* mutable_config();
  void set_allocated_config(::tensorflow::ConfigProto* config);
  void unsafe_arena_set_allocated_config(
      ::tensorflow::ConfigProto* config);
  ::tensorflow::ConfigProto* unsafe_arena_release_config();

  // @@protoc_insertion_point(class_scope:tensorflow.CreateSessionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr target_;
  ::tensorflow::GraphDef* graph_def_;
  ::tensorflow::ConfigProto* config_;
  mutable int _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto::InitDefaultsCreateSessionRequestImpl();
};
// -------------------------------------------------------------------

class CreateSessionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.CreateSessionResponse) */ {
 public:
  CreateSessionResponse();
  virtual ~CreateSessionResponse();

  CreateSessionResponse(const CreateSessionResponse& from);

  inline CreateSessionResponse& operator=(const CreateSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateSessionResponse(CreateSessionResponse&& from) noexcept
    : CreateSessionResponse() {
    *this = ::std::move(from);
  }

  inline CreateSessionResponse& operator=(CreateSessionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateSessionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateSessionResponse* internal_default_instance() {
    return reinterpret_cast<const CreateSessionResponse*>(
               &_CreateSessionResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(CreateSessionResponse* other);
  void Swap(CreateSessionResponse* other);
  friend void swap(CreateSessionResponse& a, CreateSessionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateSessionResponse* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::CreateMessage<CreateSessionResponse>(NULL);
  }

  CreateSessionResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::CreateMessage<CreateSessionResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateSessionResponse& from);
  void MergeFrom(const CreateSessionResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateSessionResponse* other);
  protected:
  explicit CreateSessionResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string session_handle = 1;
  void clear_session_handle();
  static const int kSessionHandleFieldNumber = 1;
  const ::std::string& session_handle() const;
  void set_session_handle(const ::std::string& value);
  #if LANG_CXX11
  void set_session_handle(::std::string&& value);
  #endif
  void set_session_handle(const char* value);
  void set_session_handle(const char* value, size_t size);
  ::std::string* mutable_session_handle();
  ::std::string* release_session_handle();
  void set_allocated_session_handle(::std::string* session_handle);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_session_handle();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_session_handle(
      ::std::string* session_handle);

  // int64 graph_version = 2;
  void clear_graph_version();
  static const int kGraphVersionFieldNumber = 2;
  ::google::protobuf::int64 graph_version() const;
  void set_graph_version(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.CreateSessionResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr session_handle_;
  ::google::protobuf::int64 graph_version_;
  mutable int _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto::InitDefaultsCreateSessionResponseImpl();
};
// -------------------------------------------------------------------

class ExtendSessionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.ExtendSessionRequest) */ {
 public:
  ExtendSessionRequest();
  virtual ~ExtendSessionRequest();

  ExtendSessionRequest(const ExtendSessionRequest& from);

  inline ExtendSessionRequest& operator=(const ExtendSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExtendSessionRequest(ExtendSessionRequest&& from) noexcept
    : ExtendSessionRequest() {
    *this = ::std::move(from);
  }

  inline ExtendSessionRequest& operator=(ExtendSessionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExtendSessionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExtendSessionRequest* internal_default_instance() {
    return reinterpret_cast<const ExtendSessionRequest*>(
               &_ExtendSessionRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(ExtendSessionRequest* other);
  void Swap(ExtendSessionRequest* other);
  friend void swap(ExtendSessionRequest& a, ExtendSessionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExtendSessionRequest* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::CreateMessage<ExtendSessionRequest>(NULL);
  }

  ExtendSessionRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::CreateMessage<ExtendSessionRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ExtendSessionRequest& from);
  void MergeFrom(const ExtendSessionRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ExtendSessionRequest* other);
  protected:
  explicit ExtendSessionRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string session_handle = 1;
  void clear_session_handle();
  static const int kSessionHandleFieldNumber = 1;
  const ::std::string& session_handle() const;
  void set_session_handle(const ::std::string& value);
  #if LANG_CXX11
  void set_session_handle(::std::string&& value);
  #endif
  void set_session_handle(const char* value);
  void set_session_handle(const char* value, size_t size);
  ::std::string* mutable_session_handle();
  ::std::string* release_session_handle();
  void set_allocated_session_handle(::std::string* session_handle);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_session_handle();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_session_handle(
      ::std::string* session_handle);

  // .tensorflow.GraphDef graph_def = 2;
  bool has_graph_def() const;
  void clear_graph_def();
  static const int kGraphDefFieldNumber = 2;
  const ::tensorflow::GraphDef& graph_def() const;
  ::tensorflow::GraphDef* release_graph_def();
  ::tensorflow::GraphDef* mutable_graph_def();
  void set_allocated_graph_def(::tensorflow::GraphDef* graph_def);
  void unsafe_arena_set_allocated_graph_def(
      ::tensorflow::GraphDef* graph_def);
  ::tensorflow::GraphDef* unsafe_arena_release_graph_def();

  // int64 current_graph_version = 3;
  void clear_current_graph_version();
  static const int kCurrentGraphVersionFieldNumber = 3;
  ::google::protobuf::int64 current_graph_version() const;
  void set_current_graph_version(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.ExtendSessionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr session_handle_;
  ::tensorflow::GraphDef* graph_def_;
  ::google::protobuf::int64 current_graph_version_;
  mutable int _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto::InitDefaultsExtendSessionRequestImpl();
};
// -------------------------------------------------------------------

class ExtendSessionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.ExtendSessionResponse) */ {
 public:
  ExtendSessionResponse();
  virtual ~ExtendSessionResponse();

  ExtendSessionResponse(const ExtendSessionResponse& from);

  inline ExtendSessionResponse& operator=(const ExtendSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExtendSessionResponse(ExtendSessionResponse&& from) noexcept
    : ExtendSessionResponse() {
    *this = ::std::move(from);
  }

  inline ExtendSessionResponse& operator=(ExtendSessionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExtendSessionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExtendSessionResponse* internal_default_instance() {
    return reinterpret_cast<const ExtendSessionResponse*>(
               &_ExtendSessionResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(ExtendSessionResponse* other);
  void Swap(ExtendSessionResponse* other);
  friend void swap(ExtendSessionResponse& a, ExtendSessionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExtendSessionResponse* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::CreateMessage<ExtendSessionResponse>(NULL);
  }

  ExtendSessionResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::CreateMessage<ExtendSessionResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ExtendSessionResponse& from);
  void MergeFrom(const ExtendSessionResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ExtendSessionResponse* other);
  protected:
  explicit ExtendSessionResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 new_graph_version = 4;
  void clear_new_graph_version();
  static const int kNewGraphVersionFieldNumber = 4;
  ::google::protobuf::int64 new_graph_version() const;
  void set_new_graph_version(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.ExtendSessionResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::int64 new_graph_version_;
  mutable int _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto::InitDefaultsExtendSessionResponseImpl();
};
// -------------------------------------------------------------------

class RunStepRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.RunStepRequest) */ {
 public:
  RunStepRequest();
  virtual ~RunStepRequest();

  RunStepRequest(const RunStepRequest& from);

  inline RunStepRequest& operator=(const RunStepRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RunStepRequest(RunStepRequest&& from) noexcept
    : RunStepRequest() {
    *this = ::std::move(from);
  }

  inline RunStepRequest& operator=(RunStepRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RunStepRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RunStepRequest* internal_default_instance() {
    return reinterpret_cast<const RunStepRequest*>(
               &_RunStepRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(RunStepRequest* other);
  void Swap(RunStepRequest* other);
  friend void swap(RunStepRequest& a, RunStepRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RunStepRequest* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::CreateMessage<RunStepRequest>(NULL);
  }

  RunStepRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::CreateMessage<RunStepRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RunStepRequest& from);
  void MergeFrom(const RunStepRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RunStepRequest* other);
  protected:
  explicit RunStepRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.NamedTensorProto feed = 2;
  int feed_size() const;
  void clear_feed();
  static const int kFeedFieldNumber = 2;
  ::tensorflow::NamedTensorProto* mutable_feed(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto >*
      mutable_feed();
  const ::tensorflow::NamedTensorProto& feed(int index) const;
  ::tensorflow::NamedTensorProto* add_feed();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto >&
      feed() const;

  // repeated string fetch = 3;
  int fetch_size() const;
  void clear_fetch();
  static const int kFetchFieldNumber = 3;
  const ::std::string& fetch(int index) const;
  ::std::string* mutable_fetch(int index);
  void set_fetch(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_fetch(int index, ::std::string&& value);
  #endif
  void set_fetch(int index, const char* value);
  void set_fetch(int index, const char* value, size_t size);
  ::std::string* add_fetch();
  void add_fetch(const ::std::string& value);
  #if LANG_CXX11
  void add_fetch(::std::string&& value);
  #endif
  void add_fetch(const char* value);
  void add_fetch(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& fetch() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fetch();

  // repeated string target = 4;
  int target_size() const;
  void clear_target();
  static const int kTargetFieldNumber = 4;
  const ::std::string& target(int index) const;
  ::std::string* mutable_target(int index);
  void set_target(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_target(int index, ::std::string&& value);
  #endif
  void set_target(int index, const char* value);
  void set_target(int index, const char* value, size_t size);
  ::std::string* add_target();
  void add_target(const ::std::string& value);
  #if LANG_CXX11
  void add_target(::std::string&& value);
  #endif
  void add_target(const char* value);
  void add_target(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& target() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_target();

  // string session_handle = 1;
  void clear_session_handle();
  static const int kSessionHandleFieldNumber = 1;
  const ::std::string& session_handle() const;
  void set_session_handle(const ::std::string& value);
  #if LANG_CXX11
  void set_session_handle(::std::string&& value);
  #endif
  void set_session_handle(const char* value);
  void set_session_handle(const char* value, size_t size);
  ::std::string* mutable_session_handle();
  ::std::string* release_session_handle();
  void set_allocated_session_handle(::std::string* session_handle);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_session_handle();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_session_handle(
      ::std::string* session_handle);

  // string partial_run_handle = 6;
  void clear_partial_run_handle();
  static const int kPartialRunHandleFieldNumber = 6;
  const ::std::string& partial_run_handle() const;
  void set_partial_run_handle(const ::std::string& value);
  #if LANG_CXX11
  void set_partial_run_handle(::std::string&& value);
  #endif
  void set_partial_run_handle(const char* value);
  void set_partial_run_handle(const char* value, size_t size);
  ::std::string* mutable_partial_run_handle();
  ::std::string* release_partial_run_handle();
  void set_allocated_partial_run_handle(::std::string* partial_run_handle);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_partial_run_handle();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_partial_run_handle(
      ::std::string* partial_run_handle);

  // .tensorflow.RunOptions options = 5;
  bool has_options() const;
  void clear_options();
  static const int kOptionsFieldNumber = 5;
  const ::tensorflow::RunOptions& options() const;
  ::tensorflow::RunOptions* release_options();
  ::tensorflow::RunOptions* mutable_options();
  void set_allocated_options(::tensorflow::RunOptions* options);
  void unsafe_arena_set_allocated_options(
      ::tensorflow::RunOptions* options);
  ::tensorflow::RunOptions* unsafe_arena_release_options();

  // bool store_errors_in_response_body = 7;
  void clear_store_errors_in_response_body();
  static const int kStoreErrorsInResponseBodyFieldNumber = 7;
  bool store_errors_in_response_body() const;
  void set_store_errors_in_response_body(bool value);

  // @@protoc_insertion_point(class_scope:tensorflow.RunStepRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto > feed_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fetch_;
  ::google::protobuf::RepeatedPtrField< ::std::string> target_;
  ::google::protobuf::internal::ArenaStringPtr session_handle_;
  ::google::protobuf::internal::ArenaStringPtr partial_run_handle_;
  ::tensorflow::RunOptions* options_;
  bool store_errors_in_response_body_;
  mutable int _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto::InitDefaultsRunStepRequestImpl();
};
// -------------------------------------------------------------------

class RunStepResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.RunStepResponse) */ {
 public:
  RunStepResponse();
  virtual ~RunStepResponse();

  RunStepResponse(const RunStepResponse& from);

  inline RunStepResponse& operator=(const RunStepResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RunStepResponse(RunStepResponse&& from) noexcept
    : RunStepResponse() {
    *this = ::std::move(from);
  }

  inline RunStepResponse& operator=(RunStepResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RunStepResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RunStepResponse* internal_default_instance() {
    return reinterpret_cast<const RunStepResponse*>(
               &_RunStepResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(RunStepResponse* other);
  void Swap(RunStepResponse* other);
  friend void swap(RunStepResponse& a, RunStepResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RunStepResponse* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::CreateMessage<RunStepResponse>(NULL);
  }

  RunStepResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::CreateMessage<RunStepResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RunStepResponse& from);
  void MergeFrom(const RunStepResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RunStepResponse* other);
  protected:
  explicit RunStepResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.NamedTensorProto tensor = 1;
  int tensor_size() const;
  void clear_tensor();
  static const int kTensorFieldNumber = 1;
  ::tensorflow::NamedTensorProto* mutable_tensor(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto >*
      mutable_tensor();
  const ::tensorflow::NamedTensorProto& tensor(int index) const;
  ::tensorflow::NamedTensorProto* add_tensor();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto >&
      tensor() const;

  // string status_error_message = 4;
  void clear_status_error_message();
  static const int kStatusErrorMessageFieldNumber = 4;
  const ::std::string& status_error_message() const;
  void set_status_error_message(const ::std::string& value);
  #if LANG_CXX11
  void set_status_error_message(::std::string&& value);
  #endif
  void set_status_error_message(const char* value);
  void set_status_error_message(const char* value, size_t size);
  ::std::string* mutable_status_error_message();
  ::std::string* release_status_error_message();
  void set_allocated_status_error_message(::std::string* status_error_message);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_status_error_message();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_status_error_message(
      ::std::string* status_error_message);

  // .tensorflow.RunMetadata metadata = 2;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 2;
  const ::tensorflow::RunMetadata& metadata() const;
  ::tensorflow::RunMetadata* release_metadata();
  ::tensorflow::RunMetadata* mutable_metadata();
  void set_allocated_metadata(::tensorflow::RunMetadata* metadata);
  void unsafe_arena_set_allocated_metadata(
      ::tensorflow::RunMetadata* metadata);
  ::tensorflow::RunMetadata* unsafe_arena_release_metadata();

  // .tensorflow.error.Code status_code = 3;
  void clear_status_code();
  static const int kStatusCodeFieldNumber = 3;
  ::tensorflow::error::Code status_code() const;
  void set_status_code(::tensorflow::error::Code value);

  // @@protoc_insertion_point(class_scope:tensorflow.RunStepResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto > tensor_;
  ::google::protobuf::internal::ArenaStringPtr status_error_message_;
  ::tensorflow::RunMetadata* metadata_;
  int status_code_;
  mutable int _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto::InitDefaultsRunStepResponseImpl();
};
// -------------------------------------------------------------------

class PartialRunSetupRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.PartialRunSetupRequest) */ {
 public:
  PartialRunSetupRequest();
  virtual ~PartialRunSetupRequest();

  PartialRunSetupRequest(const PartialRunSetupRequest& from);

  inline PartialRunSetupRequest& operator=(const PartialRunSetupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PartialRunSetupRequest(PartialRunSetupRequest&& from) noexcept
    : PartialRunSetupRequest() {
    *this = ::std::move(from);
  }

  inline PartialRunSetupRequest& operator=(PartialRunSetupRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PartialRunSetupRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PartialRunSetupRequest* internal_default_instance() {
    return reinterpret_cast<const PartialRunSetupRequest*>(
               &_PartialRunSetupRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(PartialRunSetupRequest* other);
  void Swap(PartialRunSetupRequest* other);
  friend void swap(PartialRunSetupRequest& a, PartialRunSetupRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PartialRunSetupRequest* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::CreateMessage<PartialRunSetupRequest>(NULL);
  }

  PartialRunSetupRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::CreateMessage<PartialRunSetupRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PartialRunSetupRequest& from);
  void MergeFrom(const PartialRunSetupRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PartialRunSetupRequest* other);
  protected:
  explicit PartialRunSetupRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string feed = 2;
  int feed_size() const;
  void clear_feed();
  static const int kFeedFieldNumber = 2;
  const ::std::string& feed(int index) const;
  ::std::string* mutable_feed(int index);
  void set_feed(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_feed(int index, ::std::string&& value);
  #endif
  void set_feed(int index, const char* value);
  void set_feed(int index, const char* value, size_t size);
  ::std::string* add_feed();
  void add_feed(const ::std::string& value);
  #if LANG_CXX11
  void add_feed(::std::string&& value);
  #endif
  void add_feed(const char* value);
  void add_feed(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& feed() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_feed();

  // repeated string fetch = 3;
  int fetch_size() const;
  void clear_fetch();
  static const int kFetchFieldNumber = 3;
  const ::std::string& fetch(int index) const;
  ::std::string* mutable_fetch(int index);
  void set_fetch(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_fetch(int index, ::std::string&& value);
  #endif
  void set_fetch(int index, const char* value);
  void set_fetch(int index, const char* value, size_t size);
  ::std::string* add_fetch();
  void add_fetch(const ::std::string& value);
  #if LANG_CXX11
  void add_fetch(::std::string&& value);
  #endif
  void add_fetch(const char* value);
  void add_fetch(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& fetch() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fetch();

  // repeated string target = 4;
  int target_size() const;
  void clear_target();
  static const int kTargetFieldNumber = 4;
  const ::std::string& target(int index) const;
  ::std::string* mutable_target(int index);
  void set_target(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_target(int index, ::std::string&& value);
  #endif
  void set_target(int index, const char* value);
  void set_target(int index, const char* value, size_t size);
  ::std::string* add_target();
  void add_target(const ::std::string& value);
  #if LANG_CXX11
  void add_target(::std::string&& value);
  #endif
  void add_target(const char* value);
  void add_target(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& target() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_target();

  // string session_handle = 1;
  void clear_session_handle();
  static const int kSessionHandleFieldNumber = 1;
  const ::std::string& session_handle() const;
  void set_session_handle(const ::std::string& value);
  #if LANG_CXX11
  void set_session_handle(::std::string&& value);
  #endif
  void set_session_handle(const char* value);
  void set_session_handle(const char* value, size_t size);
  ::std::string* mutable_session_handle();
  ::std::string* release_session_handle();
  void set_allocated_session_handle(::std::string* session_handle);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_session_handle();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_session_handle(
      ::std::string* session_handle);

  // @@protoc_insertion_point(class_scope:tensorflow.PartialRunSetupRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::std::string> feed_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fetch_;
  ::google::protobuf::RepeatedPtrField< ::std::string> target_;
  ::google::protobuf::internal::ArenaStringPtr session_handle_;
  mutable int _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto::InitDefaultsPartialRunSetupRequestImpl();
};
// -------------------------------------------------------------------

class PartialRunSetupResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.PartialRunSetupResponse) */ {
 public:
  PartialRunSetupResponse();
  virtual ~PartialRunSetupResponse();

  PartialRunSetupResponse(const PartialRunSetupResponse& from);

  inline PartialRunSetupResponse& operator=(const PartialRunSetupResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PartialRunSetupResponse(PartialRunSetupResponse&& from) noexcept
    : PartialRunSetupResponse() {
    *this = ::std::move(from);
  }

  inline PartialRunSetupResponse& operator=(PartialRunSetupResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PartialRunSetupResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PartialRunSetupResponse* internal_default_instance() {
    return reinterpret_cast<const PartialRunSetupResponse*>(
               &_PartialRunSetupResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(PartialRunSetupResponse* other);
  void Swap(PartialRunSetupResponse* other);
  friend void swap(PartialRunSetupResponse& a, PartialRunSetupResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PartialRunSetupResponse* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::CreateMessage<PartialRunSetupResponse>(NULL);
  }

  PartialRunSetupResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::CreateMessage<PartialRunSetupResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PartialRunSetupResponse& from);
  void MergeFrom(const PartialRunSetupResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PartialRunSetupResponse* other);
  protected:
  explicit PartialRunSetupResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string partial_run_handle = 1;
  void clear_partial_run_handle();
  static const int kPartialRunHandleFieldNumber = 1;
  const ::std::string& partial_run_handle() const;
  void set_partial_run_handle(const ::std::string& value);
  #if LANG_CXX11
  void set_partial_run_handle(::std::string&& value);
  #endif
  void set_partial_run_handle(const char* value);
  void set_partial_run_handle(const char* value, size_t size);
  ::std::string* mutable_partial_run_handle();
  ::std::string* release_partial_run_handle();
  void set_allocated_partial_run_handle(::std::string* partial_run_handle);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_partial_run_handle();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_partial_run_handle(
      ::std::string* partial_run_handle);

  // @@protoc_insertion_point(class_scope:tensorflow.PartialRunSetupResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr partial_run_handle_;
  mutable int _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto::InitDefaultsPartialRunSetupResponseImpl();
};
// -------------------------------------------------------------------

class CloseSessionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.CloseSessionRequest) */ {
 public:
  CloseSessionRequest();
  virtual ~CloseSessionRequest();

  CloseSessionRequest(const CloseSessionRequest& from);

  inline CloseSessionRequest& operator=(const CloseSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloseSessionRequest(CloseSessionRequest&& from) noexcept
    : CloseSessionRequest() {
    *this = ::std::move(from);
  }

  inline CloseSessionRequest& operator=(CloseSessionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseSessionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CloseSessionRequest* internal_default_instance() {
    return reinterpret_cast<const CloseSessionRequest*>(
               &_CloseSessionRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void UnsafeArenaSwap(CloseSessionRequest* other);
  void Swap(CloseSessionRequest* other);
  friend void swap(CloseSessionRequest& a, CloseSessionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloseSessionRequest* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::CreateMessage<CloseSessionRequest>(NULL);
  }

  CloseSessionRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::CreateMessage<CloseSessionRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CloseSessionRequest& from);
  void MergeFrom(const CloseSessionRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CloseSessionRequest* other);
  protected:
  explicit CloseSessionRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string session_handle = 1;
  void clear_session_handle();
  static const int kSessionHandleFieldNumber = 1;
  const ::std::string& session_handle() const;
  void set_session_handle(const ::std::string& value);
  #if LANG_CXX11
  void set_session_handle(::std::string&& value);
  #endif
  void set_session_handle(const char* value);
  void set_session_handle(const char* value, size_t size);
  ::std::string* mutable_session_handle();
  ::std::string* release_session_handle();
  void set_allocated_session_handle(::std::string* session_handle);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_session_handle();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_session_handle(
      ::std::string* session_handle);

  // @@protoc_insertion_point(class_scope:tensorflow.CloseSessionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr session_handle_;
  mutable int _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto::InitDefaultsCloseSessionRequestImpl();
};
// -------------------------------------------------------------------

class CloseSessionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.CloseSessionResponse) */ {
 public:
  CloseSessionResponse();
  virtual ~CloseSessionResponse();

  CloseSessionResponse(const CloseSessionResponse& from);

  inline CloseSessionResponse& operator=(const CloseSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloseSessionResponse(CloseSessionResponse&& from) noexcept
    : CloseSessionResponse() {
    *this = ::std::move(from);
  }

  inline CloseSessionResponse& operator=(CloseSessionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseSessionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CloseSessionResponse* internal_default_instance() {
    return reinterpret_cast<const CloseSessionResponse*>(
               &_CloseSessionResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void UnsafeArenaSwap(CloseSessionResponse* other);
  void Swap(CloseSessionResponse* other);
  friend void swap(CloseSessionResponse& a, CloseSessionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloseSessionResponse* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::CreateMessage<CloseSessionResponse>(NULL);
  }

  CloseSessionResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::CreateMessage<CloseSessionResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CloseSessionResponse& from);
  void MergeFrom(const CloseSessionResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CloseSessionResponse* other);
  protected:
  explicit CloseSessionResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.CloseSessionResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable int _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto::InitDefaultsCloseSessionResponseImpl();
};
// -------------------------------------------------------------------

class ResetRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.ResetRequest) */ {
 public:
  ResetRequest();
  virtual ~ResetRequest();

  ResetRequest(const ResetRequest& from);

  inline ResetRequest& operator=(const ResetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResetRequest(ResetRequest&& from) noexcept
    : ResetRequest() {
    *this = ::std::move(from);
  }

  inline ResetRequest& operator=(ResetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResetRequest* internal_default_instance() {
    return reinterpret_cast<const ResetRequest*>(
               &_ResetRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void UnsafeArenaSwap(ResetRequest* other);
  void Swap(ResetRequest* other);
  friend void swap(ResetRequest& a, ResetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResetRequest* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::CreateMessage<ResetRequest>(NULL);
  }

  ResetRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::CreateMessage<ResetRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResetRequest& from);
  void MergeFrom(const ResetRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResetRequest* other);
  protected:
  explicit ResetRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string container = 1;
  int container_size() const;
  void clear_container();
  static const int kContainerFieldNumber = 1;
  const ::std::string& container(int index) const;
  ::std::string* mutable_container(int index);
  void set_container(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_container(int index, ::std::string&& value);
  #endif
  void set_container(int index, const char* value);
  void set_container(int index, const char* value, size_t size);
  ::std::string* add_container();
  void add_container(const ::std::string& value);
  #if LANG_CXX11
  void add_container(::std::string&& value);
  #endif
  void add_container(const char* value);
  void add_container(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& container() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_container();

  // repeated string device_filters = 2;
  int device_filters_size() const;
  void clear_device_filters();
  static const int kDeviceFiltersFieldNumber = 2;
  const ::std::string& device_filters(int index) const;
  ::std::string* mutable_device_filters(int index);
  void set_device_filters(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_device_filters(int index, ::std::string&& value);
  #endif
  void set_device_filters(int index, const char* value);
  void set_device_filters(int index, const char* value, size_t size);
  ::std::string* add_device_filters();
  void add_device_filters(const ::std::string& value);
  #if LANG_CXX11
  void add_device_filters(::std::string&& value);
  #endif
  void add_device_filters(const char* value);
  void add_device_filters(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& device_filters() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_device_filters();

  // @@protoc_insertion_point(class_scope:tensorflow.ResetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::std::string> container_;
  ::google::protobuf::RepeatedPtrField< ::std::string> device_filters_;
  mutable int _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto::InitDefaultsResetRequestImpl();
};
// -------------------------------------------------------------------

class ResetResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.ResetResponse) */ {
 public:
  ResetResponse();
  virtual ~ResetResponse();

  ResetResponse(const ResetResponse& from);

  inline ResetResponse& operator=(const ResetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResetResponse(ResetResponse&& from) noexcept
    : ResetResponse() {
    *this = ::std::move(from);
  }

  inline ResetResponse& operator=(ResetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResetResponse* internal_default_instance() {
    return reinterpret_cast<const ResetResponse*>(
               &_ResetResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void UnsafeArenaSwap(ResetResponse* other);
  void Swap(ResetResponse* other);
  friend void swap(ResetResponse& a, ResetResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResetResponse* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::CreateMessage<ResetResponse>(NULL);
  }

  ResetResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::CreateMessage<ResetResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResetResponse& from);
  void MergeFrom(const ResetResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResetResponse* other);
  protected:
  explicit ResetResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.ResetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable int _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto::InitDefaultsResetResponseImpl();
};
// -------------------------------------------------------------------

class ListDevicesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.ListDevicesRequest) */ {
 public:
  ListDevicesRequest();
  virtual ~ListDevicesRequest();

  ListDevicesRequest(const ListDevicesRequest& from);

  inline ListDevicesRequest& operator=(const ListDevicesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListDevicesRequest(ListDevicesRequest&& from) noexcept
    : ListDevicesRequest() {
    *this = ::std::move(from);
  }

  inline ListDevicesRequest& operator=(ListDevicesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListDevicesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListDevicesRequest* internal_default_instance() {
    return reinterpret_cast<const ListDevicesRequest*>(
               &_ListDevicesRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void UnsafeArenaSwap(ListDevicesRequest* other);
  void Swap(ListDevicesRequest* other);
  friend void swap(ListDevicesRequest& a, ListDevicesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListDevicesRequest* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::CreateMessage<ListDevicesRequest>(NULL);
  }

  ListDevicesRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::CreateMessage<ListDevicesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ListDevicesRequest& from);
  void MergeFrom(const ListDevicesRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ListDevicesRequest* other);
  protected:
  explicit ListDevicesRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string session_handle = 1;
  void clear_session_handle();
  static const int kSessionHandleFieldNumber = 1;
  const ::std::string& session_handle() const;
  void set_session_handle(const ::std::string& value);
  #if LANG_CXX11
  void set_session_handle(::std::string&& value);
  #endif
  void set_session_handle(const char* value);
  void set_session_handle(const char* value, size_t size);
  ::std::string* mutable_session_handle();
  ::std::string* release_session_handle();
  void set_allocated_session_handle(::std::string* session_handle);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_session_handle();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_session_handle(
      ::std::string* session_handle);

  // @@protoc_insertion_point(class_scope:tensorflow.ListDevicesRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr session_handle_;
  mutable int _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto::InitDefaultsListDevicesRequestImpl();
};
// -------------------------------------------------------------------

class ListDevicesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.ListDevicesResponse) */ {
 public:
  ListDevicesResponse();
  virtual ~ListDevicesResponse();

  ListDevicesResponse(const ListDevicesResponse& from);

  inline ListDevicesResponse& operator=(const ListDevicesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListDevicesResponse(ListDevicesResponse&& from) noexcept
    : ListDevicesResponse() {
    *this = ::std::move(from);
  }

  inline ListDevicesResponse& operator=(ListDevicesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const PROTOBUF_FINAL {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const PROTOBUF_FINAL {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListDevicesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListDevicesResponse* internal_default_instance() {
    return reinterpret_cast<const ListDevicesResponse*>(
               &_ListDevicesResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void UnsafeArenaSwap(ListDevicesResponse* other);
  void Swap(ListDevicesResponse* other);
  friend void swap(ListDevicesResponse& a, ListDevicesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListDevicesResponse* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::CreateMessage<ListDevicesResponse>(NULL);
  }

  ListDevicesResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::CreateMessage<ListDevicesResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ListDevicesResponse& from);
  void MergeFrom(const ListDevicesResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ListDevicesResponse* other);
  protected:
  explicit ListDevicesResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.DeviceAttributes local_device = 1;
  int local_device_size() const;
  void clear_local_device();
  static const int kLocalDeviceFieldNumber = 1;
  ::tensorflow::DeviceAttributes* mutable_local_device(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes >*
      mutable_local_device();
  const ::tensorflow::DeviceAttributes& local_device(int index) const;
  ::tensorflow::DeviceAttributes* add_local_device();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes >&
      local_device() const;

  // repeated .tensorflow.DeviceAttributes remote_device = 2;
  int remote_device_size() const;
  void clear_remote_device();
  static const int kRemoteDeviceFieldNumber = 2;
  ::tensorflow::DeviceAttributes* mutable_remote_device(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes >*
      mutable_remote_device();
  const ::tensorflow::DeviceAttributes& remote_device(int index) const;
  ::tensorflow::DeviceAttributes* add_remote_device();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes >&
      remote_device() const;

  // @@protoc_insertion_point(class_scope:tensorflow.ListDevicesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes > local_device_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes > remote_device_;
  mutable int _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto::TableStruct;
  friend void ::protobuf_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto::InitDefaultsListDevicesResponseImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CreateSessionRequest

// .tensorflow.GraphDef graph_def = 1;
inline bool CreateSessionRequest::has_graph_def() const {
  return this != internal_default_instance() && graph_def_ != NULL;
}
inline const ::tensorflow::GraphDef& CreateSessionRequest::graph_def() const {
  const ::tensorflow::GraphDef* p = graph_def_;
  // @@protoc_insertion_point(field_get:tensorflow.CreateSessionRequest.graph_def)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::GraphDef*>(
      &::tensorflow::_GraphDef_default_instance_);
}
inline ::tensorflow::GraphDef* CreateSessionRequest::release_graph_def() {
  // @@protoc_insertion_point(field_release:tensorflow.CreateSessionRequest.graph_def)
  
  ::tensorflow::GraphDef* temp = graph_def_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  graph_def_ = NULL;
  return temp;
}
inline ::tensorflow::GraphDef* CreateSessionRequest::unsafe_arena_release_graph_def() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.CreateSessionRequest.graph_def)
  
  ::tensorflow::GraphDef* temp = graph_def_;
  graph_def_ = NULL;
  return temp;
}
inline ::tensorflow::GraphDef* CreateSessionRequest::mutable_graph_def() {
  
  if (graph_def_ == NULL) {
    graph_def_ = ::google::protobuf::Arena::CreateMessage< ::tensorflow::GraphDef >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.CreateSessionRequest.graph_def)
  return graph_def_;
}
inline void CreateSessionRequest::set_allocated_graph_def(::tensorflow::GraphDef* graph_def) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(graph_def_);
  }
  if (graph_def) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(graph_def)->GetArena();
    if (message_arena != submessage_arena) {
      graph_def = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, graph_def, submessage_arena);
    }
    
  } else {
    
  }
  graph_def_ = graph_def;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CreateSessionRequest.graph_def)
}

// .tensorflow.ConfigProto config = 2;
inline bool CreateSessionRequest::has_config() const {
  return this != internal_default_instance() && config_ != NULL;
}
inline const ::tensorflow::ConfigProto& CreateSessionRequest::config() const {
  const ::tensorflow::ConfigProto* p = config_;
  // @@protoc_insertion_point(field_get:tensorflow.CreateSessionRequest.config)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::ConfigProto*>(
      &::tensorflow::_ConfigProto_default_instance_);
}
inline ::tensorflow::ConfigProto* CreateSessionRequest::release_config() {
  // @@protoc_insertion_point(field_release:tensorflow.CreateSessionRequest.config)
  
  ::tensorflow::ConfigProto* temp = config_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  config_ = NULL;
  return temp;
}
inline ::tensorflow::ConfigProto* CreateSessionRequest::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.CreateSessionRequest.config)
  
  ::tensorflow::ConfigProto* temp = config_;
  config_ = NULL;
  return temp;
}
inline ::tensorflow::ConfigProto* CreateSessionRequest::mutable_config() {
  
  if (config_ == NULL) {
    config_ = ::google::protobuf::Arena::CreateMessage< ::tensorflow::ConfigProto >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.CreateSessionRequest.config)
  return config_;
}
inline void CreateSessionRequest::set_allocated_config(::tensorflow::ConfigProto* config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(config_);
  }
  if (config) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(config)->GetArena();
    if (message_arena != submessage_arena) {
      config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CreateSessionRequest.config)
}

// string target = 3;
inline void CreateSessionRequest::clear_target() {
  target_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& CreateSessionRequest::target() const {
  // @@protoc_insertion_point(field_get:tensorflow.CreateSessionRequest.target)
  return target_.Get();
}
inline void CreateSessionRequest::set_target(const ::std::string& value) {
  
  target_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.CreateSessionRequest.target)
}
#if LANG_CXX11
inline void CreateSessionRequest::set_target(::std::string&& value) {
  
  target_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.CreateSessionRequest.target)
}
#endif
inline void CreateSessionRequest::set_target(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  target_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.CreateSessionRequest.target)
}
inline void CreateSessionRequest::set_target(const char* value,
    size_t size) {
  
  target_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.CreateSessionRequest.target)
}
inline ::std::string* CreateSessionRequest::mutable_target() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.CreateSessionRequest.target)
  return target_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* CreateSessionRequest::release_target() {
  // @@protoc_insertion_point(field_release:tensorflow.CreateSessionRequest.target)
  
  return target_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void CreateSessionRequest::set_allocated_target(::std::string* target) {
  if (target != NULL) {
    
  } else {
    
  }
  target_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CreateSessionRequest.target)
}
inline ::std::string* CreateSessionRequest::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.CreateSessionRequest.target)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return target_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void CreateSessionRequest::unsafe_arena_set_allocated_target(
    ::std::string* target) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (target != NULL) {
    
  } else {
    
  }
  target_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      target, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.CreateSessionRequest.target)
}

// -------------------------------------------------------------------

// CreateSessionResponse

// string session_handle = 1;
inline void CreateSessionResponse::clear_session_handle() {
  session_handle_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& CreateSessionResponse::session_handle() const {
  // @@protoc_insertion_point(field_get:tensorflow.CreateSessionResponse.session_handle)
  return session_handle_.Get();
}
inline void CreateSessionResponse::set_session_handle(const ::std::string& value) {
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.CreateSessionResponse.session_handle)
}
#if LANG_CXX11
inline void CreateSessionResponse::set_session_handle(::std::string&& value) {
  
  session_handle_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.CreateSessionResponse.session_handle)
}
#endif
inline void CreateSessionResponse::set_session_handle(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.CreateSessionResponse.session_handle)
}
inline void CreateSessionResponse::set_session_handle(const char* value,
    size_t size) {
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.CreateSessionResponse.session_handle)
}
inline ::std::string* CreateSessionResponse::mutable_session_handle() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.CreateSessionResponse.session_handle)
  return session_handle_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* CreateSessionResponse::release_session_handle() {
  // @@protoc_insertion_point(field_release:tensorflow.CreateSessionResponse.session_handle)
  
  return session_handle_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void CreateSessionResponse::set_allocated_session_handle(::std::string* session_handle) {
  if (session_handle != NULL) {
    
  } else {
    
  }
  session_handle_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_handle,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CreateSessionResponse.session_handle)
}
inline ::std::string* CreateSessionResponse::unsafe_arena_release_session_handle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.CreateSessionResponse.session_handle)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return session_handle_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void CreateSessionResponse::unsafe_arena_set_allocated_session_handle(
    ::std::string* session_handle) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (session_handle != NULL) {
    
  } else {
    
  }
  session_handle_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      session_handle, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.CreateSessionResponse.session_handle)
}

// int64 graph_version = 2;
inline void CreateSessionResponse::clear_graph_version() {
  graph_version_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CreateSessionResponse::graph_version() const {
  // @@protoc_insertion_point(field_get:tensorflow.CreateSessionResponse.graph_version)
  return graph_version_;
}
inline void CreateSessionResponse::set_graph_version(::google::protobuf::int64 value) {
  
  graph_version_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.CreateSessionResponse.graph_version)
}

// -------------------------------------------------------------------

// ExtendSessionRequest

// string session_handle = 1;
inline void ExtendSessionRequest::clear_session_handle() {
  session_handle_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& ExtendSessionRequest::session_handle() const {
  // @@protoc_insertion_point(field_get:tensorflow.ExtendSessionRequest.session_handle)
  return session_handle_.Get();
}
inline void ExtendSessionRequest::set_session_handle(const ::std::string& value) {
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.ExtendSessionRequest.session_handle)
}
#if LANG_CXX11
inline void ExtendSessionRequest::set_session_handle(::std::string&& value) {
  
  session_handle_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.ExtendSessionRequest.session_handle)
}
#endif
inline void ExtendSessionRequest::set_session_handle(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.ExtendSessionRequest.session_handle)
}
inline void ExtendSessionRequest::set_session_handle(const char* value,
    size_t size) {
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.ExtendSessionRequest.session_handle)
}
inline ::std::string* ExtendSessionRequest::mutable_session_handle() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.ExtendSessionRequest.session_handle)
  return session_handle_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ExtendSessionRequest::release_session_handle() {
  // @@protoc_insertion_point(field_release:tensorflow.ExtendSessionRequest.session_handle)
  
  return session_handle_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ExtendSessionRequest::set_allocated_session_handle(::std::string* session_handle) {
  if (session_handle != NULL) {
    
  } else {
    
  }
  session_handle_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_handle,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.ExtendSessionRequest.session_handle)
}
inline ::std::string* ExtendSessionRequest::unsafe_arena_release_session_handle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.ExtendSessionRequest.session_handle)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return session_handle_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ExtendSessionRequest::unsafe_arena_set_allocated_session_handle(
    ::std::string* session_handle) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (session_handle != NULL) {
    
  } else {
    
  }
  session_handle_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      session_handle, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.ExtendSessionRequest.session_handle)
}

// .tensorflow.GraphDef graph_def = 2;
inline bool ExtendSessionRequest::has_graph_def() const {
  return this != internal_default_instance() && graph_def_ != NULL;
}
inline const ::tensorflow::GraphDef& ExtendSessionRequest::graph_def() const {
  const ::tensorflow::GraphDef* p = graph_def_;
  // @@protoc_insertion_point(field_get:tensorflow.ExtendSessionRequest.graph_def)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::GraphDef*>(
      &::tensorflow::_GraphDef_default_instance_);
}
inline ::tensorflow::GraphDef* ExtendSessionRequest::release_graph_def() {
  // @@protoc_insertion_point(field_release:tensorflow.ExtendSessionRequest.graph_def)
  
  ::tensorflow::GraphDef* temp = graph_def_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  graph_def_ = NULL;
  return temp;
}
inline ::tensorflow::GraphDef* ExtendSessionRequest::unsafe_arena_release_graph_def() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.ExtendSessionRequest.graph_def)
  
  ::tensorflow::GraphDef* temp = graph_def_;
  graph_def_ = NULL;
  return temp;
}
inline ::tensorflow::GraphDef* ExtendSessionRequest::mutable_graph_def() {
  
  if (graph_def_ == NULL) {
    graph_def_ = ::google::protobuf::Arena::CreateMessage< ::tensorflow::GraphDef >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.ExtendSessionRequest.graph_def)
  return graph_def_;
}
inline void ExtendSessionRequest::set_allocated_graph_def(::tensorflow::GraphDef* graph_def) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(graph_def_);
  }
  if (graph_def) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(graph_def)->GetArena();
    if (message_arena != submessage_arena) {
      graph_def = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, graph_def, submessage_arena);
    }
    
  } else {
    
  }
  graph_def_ = graph_def;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.ExtendSessionRequest.graph_def)
}

// int64 current_graph_version = 3;
inline void ExtendSessionRequest::clear_current_graph_version() {
  current_graph_version_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ExtendSessionRequest::current_graph_version() const {
  // @@protoc_insertion_point(field_get:tensorflow.ExtendSessionRequest.current_graph_version)
  return current_graph_version_;
}
inline void ExtendSessionRequest::set_current_graph_version(::google::protobuf::int64 value) {
  
  current_graph_version_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.ExtendSessionRequest.current_graph_version)
}

// -------------------------------------------------------------------

// ExtendSessionResponse

// int64 new_graph_version = 4;
inline void ExtendSessionResponse::clear_new_graph_version() {
  new_graph_version_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ExtendSessionResponse::new_graph_version() const {
  // @@protoc_insertion_point(field_get:tensorflow.ExtendSessionResponse.new_graph_version)
  return new_graph_version_;
}
inline void ExtendSessionResponse::set_new_graph_version(::google::protobuf::int64 value) {
  
  new_graph_version_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.ExtendSessionResponse.new_graph_version)
}

// -------------------------------------------------------------------

// RunStepRequest

// string session_handle = 1;
inline void RunStepRequest::clear_session_handle() {
  session_handle_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& RunStepRequest::session_handle() const {
  // @@protoc_insertion_point(field_get:tensorflow.RunStepRequest.session_handle)
  return session_handle_.Get();
}
inline void RunStepRequest::set_session_handle(const ::std::string& value) {
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.RunStepRequest.session_handle)
}
#if LANG_CXX11
inline void RunStepRequest::set_session_handle(::std::string&& value) {
  
  session_handle_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.RunStepRequest.session_handle)
}
#endif
inline void RunStepRequest::set_session_handle(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.RunStepRequest.session_handle)
}
inline void RunStepRequest::set_session_handle(const char* value,
    size_t size) {
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.RunStepRequest.session_handle)
}
inline ::std::string* RunStepRequest::mutable_session_handle() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.RunStepRequest.session_handle)
  return session_handle_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* RunStepRequest::release_session_handle() {
  // @@protoc_insertion_point(field_release:tensorflow.RunStepRequest.session_handle)
  
  return session_handle_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void RunStepRequest::set_allocated_session_handle(::std::string* session_handle) {
  if (session_handle != NULL) {
    
  } else {
    
  }
  session_handle_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_handle,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RunStepRequest.session_handle)
}
inline ::std::string* RunStepRequest::unsafe_arena_release_session_handle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.RunStepRequest.session_handle)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return session_handle_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void RunStepRequest::unsafe_arena_set_allocated_session_handle(
    ::std::string* session_handle) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (session_handle != NULL) {
    
  } else {
    
  }
  session_handle_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      session_handle, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.RunStepRequest.session_handle)
}

// repeated .tensorflow.NamedTensorProto feed = 2;
inline int RunStepRequest::feed_size() const {
  return feed_.size();
}
inline ::tensorflow::NamedTensorProto* RunStepRequest::mutable_feed(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.RunStepRequest.feed)
  return feed_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto >*
RunStepRequest::mutable_feed() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.RunStepRequest.feed)
  return &feed_;
}
inline const ::tensorflow::NamedTensorProto& RunStepRequest::feed(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.RunStepRequest.feed)
  return feed_.Get(index);
}
inline ::tensorflow::NamedTensorProto* RunStepRequest::add_feed() {
  // @@protoc_insertion_point(field_add:tensorflow.RunStepRequest.feed)
  return feed_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto >&
RunStepRequest::feed() const {
  // @@protoc_insertion_point(field_list:tensorflow.RunStepRequest.feed)
  return feed_;
}

// repeated string fetch = 3;
inline int RunStepRequest::fetch_size() const {
  return fetch_.size();
}
inline void RunStepRequest::clear_fetch() {
  fetch_.Clear();
}
inline const ::std::string& RunStepRequest::fetch(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.RunStepRequest.fetch)
  return fetch_.Get(index);
}
inline ::std::string* RunStepRequest::mutable_fetch(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.RunStepRequest.fetch)
  return fetch_.Mutable(index);
}
inline void RunStepRequest::set_fetch(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.RunStepRequest.fetch)
  fetch_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RunStepRequest::set_fetch(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tensorflow.RunStepRequest.fetch)
  fetch_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RunStepRequest::set_fetch(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fetch_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.RunStepRequest.fetch)
}
inline void RunStepRequest::set_fetch(int index, const char* value, size_t size) {
  fetch_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.RunStepRequest.fetch)
}
inline ::std::string* RunStepRequest::add_fetch() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.RunStepRequest.fetch)
  return fetch_.Add();
}
inline void RunStepRequest::add_fetch(const ::std::string& value) {
  fetch_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.RunStepRequest.fetch)
}
#if LANG_CXX11
inline void RunStepRequest::add_fetch(::std::string&& value) {
  fetch_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tensorflow.RunStepRequest.fetch)
}
#endif
inline void RunStepRequest::add_fetch(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fetch_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.RunStepRequest.fetch)
}
inline void RunStepRequest::add_fetch(const char* value, size_t size) {
  fetch_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.RunStepRequest.fetch)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RunStepRequest::fetch() const {
  // @@protoc_insertion_point(field_list:tensorflow.RunStepRequest.fetch)
  return fetch_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RunStepRequest::mutable_fetch() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.RunStepRequest.fetch)
  return &fetch_;
}

// repeated string target = 4;
inline int RunStepRequest::target_size() const {
  return target_.size();
}
inline void RunStepRequest::clear_target() {
  target_.Clear();
}
inline const ::std::string& RunStepRequest::target(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.RunStepRequest.target)
  return target_.Get(index);
}
inline ::std::string* RunStepRequest::mutable_target(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.RunStepRequest.target)
  return target_.Mutable(index);
}
inline void RunStepRequest::set_target(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.RunStepRequest.target)
  target_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RunStepRequest::set_target(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tensorflow.RunStepRequest.target)
  target_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RunStepRequest::set_target(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  target_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.RunStepRequest.target)
}
inline void RunStepRequest::set_target(int index, const char* value, size_t size) {
  target_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.RunStepRequest.target)
}
inline ::std::string* RunStepRequest::add_target() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.RunStepRequest.target)
  return target_.Add();
}
inline void RunStepRequest::add_target(const ::std::string& value) {
  target_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.RunStepRequest.target)
}
#if LANG_CXX11
inline void RunStepRequest::add_target(::std::string&& value) {
  target_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tensorflow.RunStepRequest.target)
}
#endif
inline void RunStepRequest::add_target(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  target_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.RunStepRequest.target)
}
inline void RunStepRequest::add_target(const char* value, size_t size) {
  target_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.RunStepRequest.target)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RunStepRequest::target() const {
  // @@protoc_insertion_point(field_list:tensorflow.RunStepRequest.target)
  return target_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RunStepRequest::mutable_target() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.RunStepRequest.target)
  return &target_;
}

// .tensorflow.RunOptions options = 5;
inline bool RunStepRequest::has_options() const {
  return this != internal_default_instance() && options_ != NULL;
}
inline const ::tensorflow::RunOptions& RunStepRequest::options() const {
  const ::tensorflow::RunOptions* p = options_;
  // @@protoc_insertion_point(field_get:tensorflow.RunStepRequest.options)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::RunOptions*>(
      &::tensorflow::_RunOptions_default_instance_);
}
inline ::tensorflow::RunOptions* RunStepRequest::release_options() {
  // @@protoc_insertion_point(field_release:tensorflow.RunStepRequest.options)
  
  ::tensorflow::RunOptions* temp = options_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  options_ = NULL;
  return temp;
}
inline ::tensorflow::RunOptions* RunStepRequest::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.RunStepRequest.options)
  
  ::tensorflow::RunOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline ::tensorflow::RunOptions* RunStepRequest::mutable_options() {
  
  if (options_ == NULL) {
    options_ = ::google::protobuf::Arena::CreateMessage< ::tensorflow::RunOptions >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.RunStepRequest.options)
  return options_;
}
inline void RunStepRequest::set_allocated_options(::tensorflow::RunOptions* options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(options_);
  }
  if (options) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(options)->GetArena();
    if (message_arena != submessage_arena) {
      options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RunStepRequest.options)
}

// string partial_run_handle = 6;
inline void RunStepRequest::clear_partial_run_handle() {
  partial_run_handle_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& RunStepRequest::partial_run_handle() const {
  // @@protoc_insertion_point(field_get:tensorflow.RunStepRequest.partial_run_handle)
  return partial_run_handle_.Get();
}
inline void RunStepRequest::set_partial_run_handle(const ::std::string& value) {
  
  partial_run_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.RunStepRequest.partial_run_handle)
}
#if LANG_CXX11
inline void RunStepRequest::set_partial_run_handle(::std::string&& value) {
  
  partial_run_handle_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.RunStepRequest.partial_run_handle)
}
#endif
inline void RunStepRequest::set_partial_run_handle(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  partial_run_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.RunStepRequest.partial_run_handle)
}
inline void RunStepRequest::set_partial_run_handle(const char* value,
    size_t size) {
  
  partial_run_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.RunStepRequest.partial_run_handle)
}
inline ::std::string* RunStepRequest::mutable_partial_run_handle() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.RunStepRequest.partial_run_handle)
  return partial_run_handle_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* RunStepRequest::release_partial_run_handle() {
  // @@protoc_insertion_point(field_release:tensorflow.RunStepRequest.partial_run_handle)
  
  return partial_run_handle_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void RunStepRequest::set_allocated_partial_run_handle(::std::string* partial_run_handle) {
  if (partial_run_handle != NULL) {
    
  } else {
    
  }
  partial_run_handle_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), partial_run_handle,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RunStepRequest.partial_run_handle)
}
inline ::std::string* RunStepRequest::unsafe_arena_release_partial_run_handle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.RunStepRequest.partial_run_handle)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return partial_run_handle_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void RunStepRequest::unsafe_arena_set_allocated_partial_run_handle(
    ::std::string* partial_run_handle) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (partial_run_handle != NULL) {
    
  } else {
    
  }
  partial_run_handle_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      partial_run_handle, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.RunStepRequest.partial_run_handle)
}

// bool store_errors_in_response_body = 7;
inline void RunStepRequest::clear_store_errors_in_response_body() {
  store_errors_in_response_body_ = false;
}
inline bool RunStepRequest::store_errors_in_response_body() const {
  // @@protoc_insertion_point(field_get:tensorflow.RunStepRequest.store_errors_in_response_body)
  return store_errors_in_response_body_;
}
inline void RunStepRequest::set_store_errors_in_response_body(bool value) {
  
  store_errors_in_response_body_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.RunStepRequest.store_errors_in_response_body)
}

// -------------------------------------------------------------------

// RunStepResponse

// repeated .tensorflow.NamedTensorProto tensor = 1;
inline int RunStepResponse::tensor_size() const {
  return tensor_.size();
}
inline ::tensorflow::NamedTensorProto* RunStepResponse::mutable_tensor(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.RunStepResponse.tensor)
  return tensor_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto >*
RunStepResponse::mutable_tensor() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.RunStepResponse.tensor)
  return &tensor_;
}
inline const ::tensorflow::NamedTensorProto& RunStepResponse::tensor(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.RunStepResponse.tensor)
  return tensor_.Get(index);
}
inline ::tensorflow::NamedTensorProto* RunStepResponse::add_tensor() {
  // @@protoc_insertion_point(field_add:tensorflow.RunStepResponse.tensor)
  return tensor_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::NamedTensorProto >&
RunStepResponse::tensor() const {
  // @@protoc_insertion_point(field_list:tensorflow.RunStepResponse.tensor)
  return tensor_;
}

// .tensorflow.RunMetadata metadata = 2;
inline bool RunStepResponse::has_metadata() const {
  return this != internal_default_instance() && metadata_ != NULL;
}
inline const ::tensorflow::RunMetadata& RunStepResponse::metadata() const {
  const ::tensorflow::RunMetadata* p = metadata_;
  // @@protoc_insertion_point(field_get:tensorflow.RunStepResponse.metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::RunMetadata*>(
      &::tensorflow::_RunMetadata_default_instance_);
}
inline ::tensorflow::RunMetadata* RunStepResponse::release_metadata() {
  // @@protoc_insertion_point(field_release:tensorflow.RunStepResponse.metadata)
  
  ::tensorflow::RunMetadata* temp = metadata_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp, NULL);
  }
  metadata_ = NULL;
  return temp;
}
inline ::tensorflow::RunMetadata* RunStepResponse::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.RunStepResponse.metadata)
  
  ::tensorflow::RunMetadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline ::tensorflow::RunMetadata* RunStepResponse::mutable_metadata() {
  
  if (metadata_ == NULL) {
    metadata_ = ::google::protobuf::Arena::CreateMessage< ::tensorflow::RunMetadata >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.RunStepResponse.metadata)
  return metadata_;
}
inline void RunStepResponse::set_allocated_metadata(::tensorflow::RunMetadata* metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(metadata)->GetArena();
    if (message_arena != submessage_arena) {
      metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RunStepResponse.metadata)
}

// .tensorflow.error.Code status_code = 3;
inline void RunStepResponse::clear_status_code() {
  status_code_ = 0;
}
inline ::tensorflow::error::Code RunStepResponse::status_code() const {
  // @@protoc_insertion_point(field_get:tensorflow.RunStepResponse.status_code)
  return static_cast< ::tensorflow::error::Code >(status_code_);
}
inline void RunStepResponse::set_status_code(::tensorflow::error::Code value) {
  
  status_code_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.RunStepResponse.status_code)
}

// string status_error_message = 4;
inline void RunStepResponse::clear_status_error_message() {
  status_error_message_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& RunStepResponse::status_error_message() const {
  // @@protoc_insertion_point(field_get:tensorflow.RunStepResponse.status_error_message)
  return status_error_message_.Get();
}
inline void RunStepResponse::set_status_error_message(const ::std::string& value) {
  
  status_error_message_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.RunStepResponse.status_error_message)
}
#if LANG_CXX11
inline void RunStepResponse::set_status_error_message(::std::string&& value) {
  
  status_error_message_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.RunStepResponse.status_error_message)
}
#endif
inline void RunStepResponse::set_status_error_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  status_error_message_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.RunStepResponse.status_error_message)
}
inline void RunStepResponse::set_status_error_message(const char* value,
    size_t size) {
  
  status_error_message_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.RunStepResponse.status_error_message)
}
inline ::std::string* RunStepResponse::mutable_status_error_message() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.RunStepResponse.status_error_message)
  return status_error_message_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* RunStepResponse::release_status_error_message() {
  // @@protoc_insertion_point(field_release:tensorflow.RunStepResponse.status_error_message)
  
  return status_error_message_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void RunStepResponse::set_allocated_status_error_message(::std::string* status_error_message) {
  if (status_error_message != NULL) {
    
  } else {
    
  }
  status_error_message_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status_error_message,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RunStepResponse.status_error_message)
}
inline ::std::string* RunStepResponse::unsafe_arena_release_status_error_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.RunStepResponse.status_error_message)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return status_error_message_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void RunStepResponse::unsafe_arena_set_allocated_status_error_message(
    ::std::string* status_error_message) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (status_error_message != NULL) {
    
  } else {
    
  }
  status_error_message_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      status_error_message, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.RunStepResponse.status_error_message)
}

// -------------------------------------------------------------------

// PartialRunSetupRequest

// string session_handle = 1;
inline void PartialRunSetupRequest::clear_session_handle() {
  session_handle_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& PartialRunSetupRequest::session_handle() const {
  // @@protoc_insertion_point(field_get:tensorflow.PartialRunSetupRequest.session_handle)
  return session_handle_.Get();
}
inline void PartialRunSetupRequest::set_session_handle(const ::std::string& value) {
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.PartialRunSetupRequest.session_handle)
}
#if LANG_CXX11
inline void PartialRunSetupRequest::set_session_handle(::std::string&& value) {
  
  session_handle_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.PartialRunSetupRequest.session_handle)
}
#endif
inline void PartialRunSetupRequest::set_session_handle(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.PartialRunSetupRequest.session_handle)
}
inline void PartialRunSetupRequest::set_session_handle(const char* value,
    size_t size) {
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.PartialRunSetupRequest.session_handle)
}
inline ::std::string* PartialRunSetupRequest::mutable_session_handle() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.PartialRunSetupRequest.session_handle)
  return session_handle_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* PartialRunSetupRequest::release_session_handle() {
  // @@protoc_insertion_point(field_release:tensorflow.PartialRunSetupRequest.session_handle)
  
  return session_handle_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void PartialRunSetupRequest::set_allocated_session_handle(::std::string* session_handle) {
  if (session_handle != NULL) {
    
  } else {
    
  }
  session_handle_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_handle,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.PartialRunSetupRequest.session_handle)
}
inline ::std::string* PartialRunSetupRequest::unsafe_arena_release_session_handle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.PartialRunSetupRequest.session_handle)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return session_handle_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void PartialRunSetupRequest::unsafe_arena_set_allocated_session_handle(
    ::std::string* session_handle) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (session_handle != NULL) {
    
  } else {
    
  }
  session_handle_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      session_handle, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.PartialRunSetupRequest.session_handle)
}

// repeated string feed = 2;
inline int PartialRunSetupRequest::feed_size() const {
  return feed_.size();
}
inline void PartialRunSetupRequest::clear_feed() {
  feed_.Clear();
}
inline const ::std::string& PartialRunSetupRequest::feed(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.PartialRunSetupRequest.feed)
  return feed_.Get(index);
}
inline ::std::string* PartialRunSetupRequest::mutable_feed(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.PartialRunSetupRequest.feed)
  return feed_.Mutable(index);
}
inline void PartialRunSetupRequest::set_feed(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.PartialRunSetupRequest.feed)
  feed_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void PartialRunSetupRequest::set_feed(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tensorflow.PartialRunSetupRequest.feed)
  feed_.Mutable(index)->assign(std::move(value));
}
#endif
inline void PartialRunSetupRequest::set_feed(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  feed_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.PartialRunSetupRequest.feed)
}
inline void PartialRunSetupRequest::set_feed(int index, const char* value, size_t size) {
  feed_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.PartialRunSetupRequest.feed)
}
inline ::std::string* PartialRunSetupRequest::add_feed() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.PartialRunSetupRequest.feed)
  return feed_.Add();
}
inline void PartialRunSetupRequest::add_feed(const ::std::string& value) {
  feed_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.PartialRunSetupRequest.feed)
}
#if LANG_CXX11
inline void PartialRunSetupRequest::add_feed(::std::string&& value) {
  feed_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tensorflow.PartialRunSetupRequest.feed)
}
#endif
inline void PartialRunSetupRequest::add_feed(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  feed_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.PartialRunSetupRequest.feed)
}
inline void PartialRunSetupRequest::add_feed(const char* value, size_t size) {
  feed_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.PartialRunSetupRequest.feed)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PartialRunSetupRequest::feed() const {
  // @@protoc_insertion_point(field_list:tensorflow.PartialRunSetupRequest.feed)
  return feed_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PartialRunSetupRequest::mutable_feed() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.PartialRunSetupRequest.feed)
  return &feed_;
}

// repeated string fetch = 3;
inline int PartialRunSetupRequest::fetch_size() const {
  return fetch_.size();
}
inline void PartialRunSetupRequest::clear_fetch() {
  fetch_.Clear();
}
inline const ::std::string& PartialRunSetupRequest::fetch(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.PartialRunSetupRequest.fetch)
  return fetch_.Get(index);
}
inline ::std::string* PartialRunSetupRequest::mutable_fetch(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.PartialRunSetupRequest.fetch)
  return fetch_.Mutable(index);
}
inline void PartialRunSetupRequest::set_fetch(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.PartialRunSetupRequest.fetch)
  fetch_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void PartialRunSetupRequest::set_fetch(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tensorflow.PartialRunSetupRequest.fetch)
  fetch_.Mutable(index)->assign(std::move(value));
}
#endif
inline void PartialRunSetupRequest::set_fetch(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fetch_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.PartialRunSetupRequest.fetch)
}
inline void PartialRunSetupRequest::set_fetch(int index, const char* value, size_t size) {
  fetch_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.PartialRunSetupRequest.fetch)
}
inline ::std::string* PartialRunSetupRequest::add_fetch() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.PartialRunSetupRequest.fetch)
  return fetch_.Add();
}
inline void PartialRunSetupRequest::add_fetch(const ::std::string& value) {
  fetch_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.PartialRunSetupRequest.fetch)
}
#if LANG_CXX11
inline void PartialRunSetupRequest::add_fetch(::std::string&& value) {
  fetch_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tensorflow.PartialRunSetupRequest.fetch)
}
#endif
inline void PartialRunSetupRequest::add_fetch(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fetch_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.PartialRunSetupRequest.fetch)
}
inline void PartialRunSetupRequest::add_fetch(const char* value, size_t size) {
  fetch_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.PartialRunSetupRequest.fetch)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PartialRunSetupRequest::fetch() const {
  // @@protoc_insertion_point(field_list:tensorflow.PartialRunSetupRequest.fetch)
  return fetch_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PartialRunSetupRequest::mutable_fetch() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.PartialRunSetupRequest.fetch)
  return &fetch_;
}

// repeated string target = 4;
inline int PartialRunSetupRequest::target_size() const {
  return target_.size();
}
inline void PartialRunSetupRequest::clear_target() {
  target_.Clear();
}
inline const ::std::string& PartialRunSetupRequest::target(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.PartialRunSetupRequest.target)
  return target_.Get(index);
}
inline ::std::string* PartialRunSetupRequest::mutable_target(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.PartialRunSetupRequest.target)
  return target_.Mutable(index);
}
inline void PartialRunSetupRequest::set_target(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.PartialRunSetupRequest.target)
  target_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void PartialRunSetupRequest::set_target(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tensorflow.PartialRunSetupRequest.target)
  target_.Mutable(index)->assign(std::move(value));
}
#endif
inline void PartialRunSetupRequest::set_target(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  target_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.PartialRunSetupRequest.target)
}
inline void PartialRunSetupRequest::set_target(int index, const char* value, size_t size) {
  target_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.PartialRunSetupRequest.target)
}
inline ::std::string* PartialRunSetupRequest::add_target() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.PartialRunSetupRequest.target)
  return target_.Add();
}
inline void PartialRunSetupRequest::add_target(const ::std::string& value) {
  target_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.PartialRunSetupRequest.target)
}
#if LANG_CXX11
inline void PartialRunSetupRequest::add_target(::std::string&& value) {
  target_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tensorflow.PartialRunSetupRequest.target)
}
#endif
inline void PartialRunSetupRequest::add_target(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  target_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.PartialRunSetupRequest.target)
}
inline void PartialRunSetupRequest::add_target(const char* value, size_t size) {
  target_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.PartialRunSetupRequest.target)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PartialRunSetupRequest::target() const {
  // @@protoc_insertion_point(field_list:tensorflow.PartialRunSetupRequest.target)
  return target_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PartialRunSetupRequest::mutable_target() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.PartialRunSetupRequest.target)
  return &target_;
}

// -------------------------------------------------------------------

// PartialRunSetupResponse

// string partial_run_handle = 1;
inline void PartialRunSetupResponse::clear_partial_run_handle() {
  partial_run_handle_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& PartialRunSetupResponse::partial_run_handle() const {
  // @@protoc_insertion_point(field_get:tensorflow.PartialRunSetupResponse.partial_run_handle)
  return partial_run_handle_.Get();
}
inline void PartialRunSetupResponse::set_partial_run_handle(const ::std::string& value) {
  
  partial_run_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.PartialRunSetupResponse.partial_run_handle)
}
#if LANG_CXX11
inline void PartialRunSetupResponse::set_partial_run_handle(::std::string&& value) {
  
  partial_run_handle_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.PartialRunSetupResponse.partial_run_handle)
}
#endif
inline void PartialRunSetupResponse::set_partial_run_handle(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  partial_run_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.PartialRunSetupResponse.partial_run_handle)
}
inline void PartialRunSetupResponse::set_partial_run_handle(const char* value,
    size_t size) {
  
  partial_run_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.PartialRunSetupResponse.partial_run_handle)
}
inline ::std::string* PartialRunSetupResponse::mutable_partial_run_handle() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.PartialRunSetupResponse.partial_run_handle)
  return partial_run_handle_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* PartialRunSetupResponse::release_partial_run_handle() {
  // @@protoc_insertion_point(field_release:tensorflow.PartialRunSetupResponse.partial_run_handle)
  
  return partial_run_handle_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void PartialRunSetupResponse::set_allocated_partial_run_handle(::std::string* partial_run_handle) {
  if (partial_run_handle != NULL) {
    
  } else {
    
  }
  partial_run_handle_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), partial_run_handle,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.PartialRunSetupResponse.partial_run_handle)
}
inline ::std::string* PartialRunSetupResponse::unsafe_arena_release_partial_run_handle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.PartialRunSetupResponse.partial_run_handle)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return partial_run_handle_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void PartialRunSetupResponse::unsafe_arena_set_allocated_partial_run_handle(
    ::std::string* partial_run_handle) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (partial_run_handle != NULL) {
    
  } else {
    
  }
  partial_run_handle_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      partial_run_handle, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.PartialRunSetupResponse.partial_run_handle)
}

// -------------------------------------------------------------------

// CloseSessionRequest

// string session_handle = 1;
inline void CloseSessionRequest::clear_session_handle() {
  session_handle_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& CloseSessionRequest::session_handle() const {
  // @@protoc_insertion_point(field_get:tensorflow.CloseSessionRequest.session_handle)
  return session_handle_.Get();
}
inline void CloseSessionRequest::set_session_handle(const ::std::string& value) {
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.CloseSessionRequest.session_handle)
}
#if LANG_CXX11
inline void CloseSessionRequest::set_session_handle(::std::string&& value) {
  
  session_handle_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.CloseSessionRequest.session_handle)
}
#endif
inline void CloseSessionRequest::set_session_handle(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.CloseSessionRequest.session_handle)
}
inline void CloseSessionRequest::set_session_handle(const char* value,
    size_t size) {
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.CloseSessionRequest.session_handle)
}
inline ::std::string* CloseSessionRequest::mutable_session_handle() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.CloseSessionRequest.session_handle)
  return session_handle_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* CloseSessionRequest::release_session_handle() {
  // @@protoc_insertion_point(field_release:tensorflow.CloseSessionRequest.session_handle)
  
  return session_handle_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void CloseSessionRequest::set_allocated_session_handle(::std::string* session_handle) {
  if (session_handle != NULL) {
    
  } else {
    
  }
  session_handle_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_handle,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CloseSessionRequest.session_handle)
}
inline ::std::string* CloseSessionRequest::unsafe_arena_release_session_handle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.CloseSessionRequest.session_handle)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return session_handle_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void CloseSessionRequest::unsafe_arena_set_allocated_session_handle(
    ::std::string* session_handle) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (session_handle != NULL) {
    
  } else {
    
  }
  session_handle_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      session_handle, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.CloseSessionRequest.session_handle)
}

// -------------------------------------------------------------------

// CloseSessionResponse

// -------------------------------------------------------------------

// ResetRequest

// repeated string container = 1;
inline int ResetRequest::container_size() const {
  return container_.size();
}
inline void ResetRequest::clear_container() {
  container_.Clear();
}
inline const ::std::string& ResetRequest::container(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.ResetRequest.container)
  return container_.Get(index);
}
inline ::std::string* ResetRequest::mutable_container(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.ResetRequest.container)
  return container_.Mutable(index);
}
inline void ResetRequest::set_container(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.ResetRequest.container)
  container_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ResetRequest::set_container(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tensorflow.ResetRequest.container)
  container_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ResetRequest::set_container(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  container_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.ResetRequest.container)
}
inline void ResetRequest::set_container(int index, const char* value, size_t size) {
  container_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.ResetRequest.container)
}
inline ::std::string* ResetRequest::add_container() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.ResetRequest.container)
  return container_.Add();
}
inline void ResetRequest::add_container(const ::std::string& value) {
  container_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.ResetRequest.container)
}
#if LANG_CXX11
inline void ResetRequest::add_container(::std::string&& value) {
  container_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tensorflow.ResetRequest.container)
}
#endif
inline void ResetRequest::add_container(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  container_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.ResetRequest.container)
}
inline void ResetRequest::add_container(const char* value, size_t size) {
  container_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.ResetRequest.container)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ResetRequest::container() const {
  // @@protoc_insertion_point(field_list:tensorflow.ResetRequest.container)
  return container_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ResetRequest::mutable_container() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.ResetRequest.container)
  return &container_;
}

// repeated string device_filters = 2;
inline int ResetRequest::device_filters_size() const {
  return device_filters_.size();
}
inline void ResetRequest::clear_device_filters() {
  device_filters_.Clear();
}
inline const ::std::string& ResetRequest::device_filters(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.ResetRequest.device_filters)
  return device_filters_.Get(index);
}
inline ::std::string* ResetRequest::mutable_device_filters(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.ResetRequest.device_filters)
  return device_filters_.Mutable(index);
}
inline void ResetRequest::set_device_filters(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.ResetRequest.device_filters)
  device_filters_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ResetRequest::set_device_filters(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tensorflow.ResetRequest.device_filters)
  device_filters_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ResetRequest::set_device_filters(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  device_filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.ResetRequest.device_filters)
}
inline void ResetRequest::set_device_filters(int index, const char* value, size_t size) {
  device_filters_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.ResetRequest.device_filters)
}
inline ::std::string* ResetRequest::add_device_filters() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.ResetRequest.device_filters)
  return device_filters_.Add();
}
inline void ResetRequest::add_device_filters(const ::std::string& value) {
  device_filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.ResetRequest.device_filters)
}
#if LANG_CXX11
inline void ResetRequest::add_device_filters(::std::string&& value) {
  device_filters_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tensorflow.ResetRequest.device_filters)
}
#endif
inline void ResetRequest::add_device_filters(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  device_filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.ResetRequest.device_filters)
}
inline void ResetRequest::add_device_filters(const char* value, size_t size) {
  device_filters_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.ResetRequest.device_filters)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ResetRequest::device_filters() const {
  // @@protoc_insertion_point(field_list:tensorflow.ResetRequest.device_filters)
  return device_filters_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ResetRequest::mutable_device_filters() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.ResetRequest.device_filters)
  return &device_filters_;
}

// -------------------------------------------------------------------

// ResetResponse

// -------------------------------------------------------------------

// ListDevicesRequest

// string session_handle = 1;
inline void ListDevicesRequest::clear_session_handle() {
  session_handle_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& ListDevicesRequest::session_handle() const {
  // @@protoc_insertion_point(field_get:tensorflow.ListDevicesRequest.session_handle)
  return session_handle_.Get();
}
inline void ListDevicesRequest::set_session_handle(const ::std::string& value) {
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.ListDevicesRequest.session_handle)
}
#if LANG_CXX11
inline void ListDevicesRequest::set_session_handle(::std::string&& value) {
  
  session_handle_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.ListDevicesRequest.session_handle)
}
#endif
inline void ListDevicesRequest::set_session_handle(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.ListDevicesRequest.session_handle)
}
inline void ListDevicesRequest::set_session_handle(const char* value,
    size_t size) {
  
  session_handle_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.ListDevicesRequest.session_handle)
}
inline ::std::string* ListDevicesRequest::mutable_session_handle() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.ListDevicesRequest.session_handle)
  return session_handle_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ListDevicesRequest::release_session_handle() {
  // @@protoc_insertion_point(field_release:tensorflow.ListDevicesRequest.session_handle)
  
  return session_handle_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ListDevicesRequest::set_allocated_session_handle(::std::string* session_handle) {
  if (session_handle != NULL) {
    
  } else {
    
  }
  session_handle_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_handle,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.ListDevicesRequest.session_handle)
}
inline ::std::string* ListDevicesRequest::unsafe_arena_release_session_handle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.ListDevicesRequest.session_handle)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return session_handle_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ListDevicesRequest::unsafe_arena_set_allocated_session_handle(
    ::std::string* session_handle) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (session_handle != NULL) {
    
  } else {
    
  }
  session_handle_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      session_handle, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.ListDevicesRequest.session_handle)
}

// -------------------------------------------------------------------

// ListDevicesResponse

// repeated .tensorflow.DeviceAttributes local_device = 1;
inline int ListDevicesResponse::local_device_size() const {
  return local_device_.size();
}
inline ::tensorflow::DeviceAttributes* ListDevicesResponse::mutable_local_device(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.ListDevicesResponse.local_device)
  return local_device_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes >*
ListDevicesResponse::mutable_local_device() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.ListDevicesResponse.local_device)
  return &local_device_;
}
inline const ::tensorflow::DeviceAttributes& ListDevicesResponse::local_device(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.ListDevicesResponse.local_device)
  return local_device_.Get(index);
}
inline ::tensorflow::DeviceAttributes* ListDevicesResponse::add_local_device() {
  // @@protoc_insertion_point(field_add:tensorflow.ListDevicesResponse.local_device)
  return local_device_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes >&
ListDevicesResponse::local_device() const {
  // @@protoc_insertion_point(field_list:tensorflow.ListDevicesResponse.local_device)
  return local_device_;
}

// repeated .tensorflow.DeviceAttributes remote_device = 2;
inline int ListDevicesResponse::remote_device_size() const {
  return remote_device_.size();
}
inline ::tensorflow::DeviceAttributes* ListDevicesResponse::mutable_remote_device(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.ListDevicesResponse.remote_device)
  return remote_device_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes >*
ListDevicesResponse::mutable_remote_device() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.ListDevicesResponse.remote_device)
  return &remote_device_;
}
inline const ::tensorflow::DeviceAttributes& ListDevicesResponse::remote_device(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.ListDevicesResponse.remote_device)
  return remote_device_.Get(index);
}
inline ::tensorflow::DeviceAttributes* ListDevicesResponse::add_remote_device() {
  // @@protoc_insertion_point(field_add:tensorflow.ListDevicesResponse.remote_device)
  return remote_device_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes >&
ListDevicesResponse::remote_device() const {
  // @@protoc_insertion_point(field_list:tensorflow.ListDevicesResponse.remote_device)
  return remote_device_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tensorflow

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tensorflow_2fcore_2fprotobuf_2fmaster_2eproto_INCLUDED
