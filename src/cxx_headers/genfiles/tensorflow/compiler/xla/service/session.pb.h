// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/compiler/xla/service/session.proto

#ifndef PROTOBUF_tensorflow_2fcompiler_2fxla_2fservice_2fsession_2eproto_INCLUDED
#define PROTOBUF_tensorflow_2fcompiler_2fxla_2fservice_2fsession_2eproto_INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "tensorflow/compiler/xla/xla_data.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_tensorflow_2fcompiler_2fxla_2fservice_2fsession_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsOperationRequestImpl();
void InitDefaultsOperationRequest();
void InitDefaultsSessionComputation_RequestsEntry_DoNotUseImpl();
void InitDefaultsSessionComputation_RequestsEntry_DoNotUse();
void InitDefaultsSessionComputationImpl();
void InitDefaultsSessionComputation();
void InitDefaultsSessionModuleImpl();
void InitDefaultsSessionModule();
inline void InitDefaults() {
  InitDefaultsOperationRequest();
  InitDefaultsSessionComputation_RequestsEntry_DoNotUse();
  InitDefaultsSessionComputation();
  InitDefaultsSessionModule();
}
}  // namespace protobuf_tensorflow_2fcompiler_2fxla_2fservice_2fsession_2eproto
namespace xla {
class OperationRequest;
class OperationRequestDefaultTypeInternal;
extern OperationRequestDefaultTypeInternal _OperationRequest_default_instance_;
class SessionComputation;
class SessionComputationDefaultTypeInternal;
extern SessionComputationDefaultTypeInternal _SessionComputation_default_instance_;
class SessionComputation_RequestsEntry_DoNotUse;
class SessionComputation_RequestsEntry_DoNotUseDefaultTypeInternal;
extern SessionComputation_RequestsEntry_DoNotUseDefaultTypeInternal _SessionComputation_RequestsEntry_DoNotUse_default_instance_;
class SessionModule;
class SessionModuleDefaultTypeInternal;
extern SessionModuleDefaultTypeInternal _SessionModule_default_instance_;
}  // namespace xla
namespace google {
namespace protobuf {
template<> ::xla::OperationRequest* Arena::Create< ::xla::OperationRequest>(Arena*);
template<> ::xla::SessionComputation* Arena::Create< ::xla::SessionComputation>(Arena*);
template<> ::xla::SessionComputation_RequestsEntry_DoNotUse* Arena::Create< ::xla::SessionComputation_RequestsEntry_DoNotUse>(Arena*);
template<> ::xla::SessionModule* Arena::Create< ::xla::SessionModule>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace xla {

// ===================================================================

class OperationRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xla.OperationRequest) */ {
 public:
  OperationRequest();
  virtual ~OperationRequest();

  OperationRequest(const OperationRequest& from);

  inline OperationRequest& operator=(const OperationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OperationRequest(OperationRequest&& from) noexcept
    : OperationRequest() {
    *this = ::std::move(from);
  }

  inline OperationRequest& operator=(OperationRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OperationRequest* internal_default_instance() {
    return reinterpret_cast<const OperationRequest*>(
               &_OperationRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(OperationRequest* other);
  friend void swap(OperationRequest& a, OperationRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OperationRequest* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<OperationRequest>(NULL);
  }

  OperationRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<OperationRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OperationRequest& from);
  void MergeFrom(const OperationRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OperationRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 embedded_computation_versions = 3;
  int embedded_computation_versions_size() const;
  void clear_embedded_computation_versions();
  static const int kEmbeddedComputationVersionsFieldNumber = 3;
  ::google::protobuf::int64 embedded_computation_versions(int index) const;
  void set_embedded_computation_versions(int index, ::google::protobuf::int64 value);
  void add_embedded_computation_versions(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      embedded_computation_versions() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_embedded_computation_versions();

  // .xla.ComputationDataHandle output_handle = 1;
  bool has_output_handle() const;
  void clear_output_handle();
  static const int kOutputHandleFieldNumber = 1;
  const ::xla::ComputationDataHandle& output_handle() const;
  ::xla::ComputationDataHandle* release_output_handle();
  ::xla::ComputationDataHandle* mutable_output_handle();
  void set_allocated_output_handle(::xla::ComputationDataHandle* output_handle);

  // .xla.Shape output_shape = 2;
  bool has_output_shape() const;
  void clear_output_shape();
  static const int kOutputShapeFieldNumber = 2;
  const ::xla::Shape& output_shape() const;
  ::xla::Shape* release_output_shape();
  ::xla::Shape* mutable_output_shape();
  void set_allocated_output_shape(::xla::Shape* output_shape);

  // .xla.OpRequest request = 4;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 4;
  const ::xla::OpRequest& request() const;
  ::xla::OpRequest* release_request();
  ::xla::OpRequest* mutable_request();
  void set_allocated_request(::xla::OpRequest* request);

  // @@protoc_insertion_point(class_scope:xla.OperationRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > embedded_computation_versions_;
  mutable int _embedded_computation_versions_cached_byte_size_;
  ::xla::ComputationDataHandle* output_handle_;
  ::xla::Shape* output_shape_;
  ::xla::OpRequest* request_;
  mutable int _cached_size_;
  friend struct ::protobuf_tensorflow_2fcompiler_2fxla_2fservice_2fsession_2eproto::TableStruct;
  friend void ::protobuf_tensorflow_2fcompiler_2fxla_2fservice_2fsession_2eproto::InitDefaultsOperationRequestImpl();
};
// -------------------------------------------------------------------

class SessionComputation_RequestsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<SessionComputation_RequestsEntry_DoNotUse, 
    ::google::protobuf::int64, ::xla::OperationRequest,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<SessionComputation_RequestsEntry_DoNotUse, 
    ::google::protobuf::int64, ::xla::OperationRequest,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  SessionComputation_RequestsEntry_DoNotUse();
  SessionComputation_RequestsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const SessionComputation_RequestsEntry_DoNotUse& other);
  static const SessionComputation_RequestsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SessionComputation_RequestsEntry_DoNotUse*>(&_SessionComputation_RequestsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class SessionComputation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xla.SessionComputation) */ {
 public:
  SessionComputation();
  virtual ~SessionComputation();

  SessionComputation(const SessionComputation& from);

  inline SessionComputation& operator=(const SessionComputation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SessionComputation(SessionComputation&& from) noexcept
    : SessionComputation() {
    *this = ::std::move(from);
  }

  inline SessionComputation& operator=(SessionComputation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SessionComputation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SessionComputation* internal_default_instance() {
    return reinterpret_cast<const SessionComputation*>(
               &_SessionComputation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(SessionComputation* other);
  friend void swap(SessionComputation& a, SessionComputation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SessionComputation* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<SessionComputation>(NULL);
  }

  SessionComputation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<SessionComputation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SessionComputation& from);
  void MergeFrom(const SessionComputation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SessionComputation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<int64, .xla.OperationRequest> requests = 3;
  int requests_size() const;
  void clear_requests();
  static const int kRequestsFieldNumber = 3;
  const ::google::protobuf::Map< ::google::protobuf::int64, ::xla::OperationRequest >&
      requests() const;
  ::google::protobuf::Map< ::google::protobuf::int64, ::xla::OperationRequest >*
      mutable_requests();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .xla.ComputationHandle computation_handle = 2;
  bool has_computation_handle() const;
  void clear_computation_handle();
  static const int kComputationHandleFieldNumber = 2;
  const ::xla::ComputationHandle& computation_handle() const;
  ::xla::ComputationHandle* release_computation_handle();
  ::xla::ComputationHandle* mutable_computation_handle();
  void set_allocated_computation_handle(::xla::ComputationHandle* computation_handle);

  // @@protoc_insertion_point(class_scope:xla.SessionComputation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      SessionComputation_RequestsEntry_DoNotUse,
      ::google::protobuf::int64, ::xla::OperationRequest,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT64,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > requests_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::xla::ComputationHandle* computation_handle_;
  mutable int _cached_size_;
  friend struct ::protobuf_tensorflow_2fcompiler_2fxla_2fservice_2fsession_2eproto::TableStruct;
  friend void ::protobuf_tensorflow_2fcompiler_2fxla_2fservice_2fsession_2eproto::InitDefaultsSessionComputationImpl();
};
// -------------------------------------------------------------------

class SessionModule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xla.SessionModule) */ {
 public:
  SessionModule();
  virtual ~SessionModule();

  SessionModule(const SessionModule& from);

  inline SessionModule& operator=(const SessionModule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SessionModule(SessionModule&& from) noexcept
    : SessionModule() {
    *this = ::std::move(from);
  }

  inline SessionModule& operator=(SessionModule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SessionModule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SessionModule* internal_default_instance() {
    return reinterpret_cast<const SessionModule*>(
               &_SessionModule_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(SessionModule* other);
  friend void swap(SessionModule& a, SessionModule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SessionModule* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<SessionModule>(NULL);
  }

  SessionModule* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<SessionModule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SessionModule& from);
  void MergeFrom(const SessionModule& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SessionModule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xla.SessionComputation embedded_computations = 2;
  int embedded_computations_size() const;
  void clear_embedded_computations();
  static const int kEmbeddedComputationsFieldNumber = 2;
  ::xla::SessionComputation* mutable_embedded_computations(int index);
  ::google::protobuf::RepeatedPtrField< ::xla::SessionComputation >*
      mutable_embedded_computations();
  const ::xla::SessionComputation& embedded_computations(int index) const;
  ::xla::SessionComputation* add_embedded_computations();
  const ::google::protobuf::RepeatedPtrField< ::xla::SessionComputation >&
      embedded_computations() const;

  // repeated .xla.LiteralProto arguments = 3;
  int arguments_size() const;
  void clear_arguments();
  static const int kArgumentsFieldNumber = 3;
  ::xla::LiteralProto* mutable_arguments(int index);
  ::google::protobuf::RepeatedPtrField< ::xla::LiteralProto >*
      mutable_arguments();
  const ::xla::LiteralProto& arguments(int index) const;
  ::xla::LiteralProto* add_arguments();
  const ::google::protobuf::RepeatedPtrField< ::xla::LiteralProto >&
      arguments() const;

  // string execution_platform = 5;
  void clear_execution_platform();
  static const int kExecutionPlatformFieldNumber = 5;
  const ::std::string& execution_platform() const;
  void set_execution_platform(const ::std::string& value);
  #if LANG_CXX11
  void set_execution_platform(::std::string&& value);
  #endif
  void set_execution_platform(const char* value);
  void set_execution_platform(const char* value, size_t size);
  ::std::string* mutable_execution_platform();
  ::std::string* release_execution_platform();
  void set_allocated_execution_platform(::std::string* execution_platform);

  // .xla.SessionComputation entry = 1;
  bool has_entry() const;
  void clear_entry();
  static const int kEntryFieldNumber = 1;
  const ::xla::SessionComputation& entry() const;
  ::xla::SessionComputation* release_entry();
  ::xla::SessionComputation* mutable_entry();
  void set_allocated_entry(::xla::SessionComputation* entry);

  // .xla.LiteralProto result = 4;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 4;
  const ::xla::LiteralProto& result() const;
  ::xla::LiteralProto* release_result();
  ::xla::LiteralProto* mutable_result();
  void set_allocated_result(::xla::LiteralProto* result);

  // @@protoc_insertion_point(class_scope:xla.SessionModule)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::xla::SessionComputation > embedded_computations_;
  ::google::protobuf::RepeatedPtrField< ::xla::LiteralProto > arguments_;
  ::google::protobuf::internal::ArenaStringPtr execution_platform_;
  ::xla::SessionComputation* entry_;
  ::xla::LiteralProto* result_;
  mutable int _cached_size_;
  friend struct ::protobuf_tensorflow_2fcompiler_2fxla_2fservice_2fsession_2eproto::TableStruct;
  friend void ::protobuf_tensorflow_2fcompiler_2fxla_2fservice_2fsession_2eproto::InitDefaultsSessionModuleImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// OperationRequest

// .xla.ComputationDataHandle output_handle = 1;
inline bool OperationRequest::has_output_handle() const {
  return this != internal_default_instance() && output_handle_ != NULL;
}
inline const ::xla::ComputationDataHandle& OperationRequest::output_handle() const {
  const ::xla::ComputationDataHandle* p = output_handle_;
  // @@protoc_insertion_point(field_get:xla.OperationRequest.output_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::xla::ComputationDataHandle*>(
      &::xla::_ComputationDataHandle_default_instance_);
}
inline ::xla::ComputationDataHandle* OperationRequest::release_output_handle() {
  // @@protoc_insertion_point(field_release:xla.OperationRequest.output_handle)
  
  ::xla::ComputationDataHandle* temp = output_handle_;
  output_handle_ = NULL;
  return temp;
}
inline ::xla::ComputationDataHandle* OperationRequest::mutable_output_handle() {
  
  if (output_handle_ == NULL) {
    output_handle_ = ::google::protobuf::Arena::CreateMessage< ::xla::ComputationDataHandle >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:xla.OperationRequest.output_handle)
  return output_handle_;
}
inline void OperationRequest::set_allocated_output_handle(::xla::ComputationDataHandle* output_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(output_handle_);
  }
  if (output_handle) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(output_handle)->GetArena();
    if (message_arena != submessage_arena) {
      output_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, output_handle, submessage_arena);
    }
    
  } else {
    
  }
  output_handle_ = output_handle;
  // @@protoc_insertion_point(field_set_allocated:xla.OperationRequest.output_handle)
}

// .xla.Shape output_shape = 2;
inline bool OperationRequest::has_output_shape() const {
  return this != internal_default_instance() && output_shape_ != NULL;
}
inline const ::xla::Shape& OperationRequest::output_shape() const {
  const ::xla::Shape* p = output_shape_;
  // @@protoc_insertion_point(field_get:xla.OperationRequest.output_shape)
  return p != NULL ? *p : *reinterpret_cast<const ::xla::Shape*>(
      &::xla::_Shape_default_instance_);
}
inline ::xla::Shape* OperationRequest::release_output_shape() {
  // @@protoc_insertion_point(field_release:xla.OperationRequest.output_shape)
  
  ::xla::Shape* temp = output_shape_;
  output_shape_ = NULL;
  return temp;
}
inline ::xla::Shape* OperationRequest::mutable_output_shape() {
  
  if (output_shape_ == NULL) {
    output_shape_ = ::google::protobuf::Arena::CreateMessage< ::xla::Shape >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:xla.OperationRequest.output_shape)
  return output_shape_;
}
inline void OperationRequest::set_allocated_output_shape(::xla::Shape* output_shape) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(output_shape_);
  }
  if (output_shape) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(output_shape)->GetArena();
    if (message_arena != submessage_arena) {
      output_shape = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, output_shape, submessage_arena);
    }
    
  } else {
    
  }
  output_shape_ = output_shape;
  // @@protoc_insertion_point(field_set_allocated:xla.OperationRequest.output_shape)
}

// repeated int64 embedded_computation_versions = 3;
inline int OperationRequest::embedded_computation_versions_size() const {
  return embedded_computation_versions_.size();
}
inline void OperationRequest::clear_embedded_computation_versions() {
  embedded_computation_versions_.Clear();
}
inline ::google::protobuf::int64 OperationRequest::embedded_computation_versions(int index) const {
  // @@protoc_insertion_point(field_get:xla.OperationRequest.embedded_computation_versions)
  return embedded_computation_versions_.Get(index);
}
inline void OperationRequest::set_embedded_computation_versions(int index, ::google::protobuf::int64 value) {
  embedded_computation_versions_.Set(index, value);
  // @@protoc_insertion_point(field_set:xla.OperationRequest.embedded_computation_versions)
}
inline void OperationRequest::add_embedded_computation_versions(::google::protobuf::int64 value) {
  embedded_computation_versions_.Add(value);
  // @@protoc_insertion_point(field_add:xla.OperationRequest.embedded_computation_versions)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
OperationRequest::embedded_computation_versions() const {
  // @@protoc_insertion_point(field_list:xla.OperationRequest.embedded_computation_versions)
  return embedded_computation_versions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
OperationRequest::mutable_embedded_computation_versions() {
  // @@protoc_insertion_point(field_mutable_list:xla.OperationRequest.embedded_computation_versions)
  return &embedded_computation_versions_;
}

// .xla.OpRequest request = 4;
inline bool OperationRequest::has_request() const {
  return this != internal_default_instance() && request_ != NULL;
}
inline const ::xla::OpRequest& OperationRequest::request() const {
  const ::xla::OpRequest* p = request_;
  // @@protoc_insertion_point(field_get:xla.OperationRequest.request)
  return p != NULL ? *p : *reinterpret_cast<const ::xla::OpRequest*>(
      &::xla::_OpRequest_default_instance_);
}
inline ::xla::OpRequest* OperationRequest::release_request() {
  // @@protoc_insertion_point(field_release:xla.OperationRequest.request)
  
  ::xla::OpRequest* temp = request_;
  request_ = NULL;
  return temp;
}
inline ::xla::OpRequest* OperationRequest::mutable_request() {
  
  if (request_ == NULL) {
    request_ = ::google::protobuf::Arena::CreateMessage< ::xla::OpRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:xla.OperationRequest.request)
  return request_;
}
inline void OperationRequest::set_allocated_request(::xla::OpRequest* request) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(request_);
  }
  if (request) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(request)->GetArena();
    if (message_arena != submessage_arena) {
      request = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:xla.OperationRequest.request)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SessionComputation

// string name = 1;
inline void SessionComputation::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SessionComputation::name() const {
  // @@protoc_insertion_point(field_get:xla.SessionComputation.name)
  return name_.GetNoArena();
}
inline void SessionComputation::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xla.SessionComputation.name)
}
#if LANG_CXX11
inline void SessionComputation::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xla.SessionComputation.name)
}
#endif
inline void SessionComputation::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xla.SessionComputation.name)
}
inline void SessionComputation::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xla.SessionComputation.name)
}
inline ::std::string* SessionComputation::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:xla.SessionComputation.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SessionComputation::release_name() {
  // @@protoc_insertion_point(field_release:xla.SessionComputation.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionComputation::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:xla.SessionComputation.name)
}

// .xla.ComputationHandle computation_handle = 2;
inline bool SessionComputation::has_computation_handle() const {
  return this != internal_default_instance() && computation_handle_ != NULL;
}
inline const ::xla::ComputationHandle& SessionComputation::computation_handle() const {
  const ::xla::ComputationHandle* p = computation_handle_;
  // @@protoc_insertion_point(field_get:xla.SessionComputation.computation_handle)
  return p != NULL ? *p : *reinterpret_cast<const ::xla::ComputationHandle*>(
      &::xla::_ComputationHandle_default_instance_);
}
inline ::xla::ComputationHandle* SessionComputation::release_computation_handle() {
  // @@protoc_insertion_point(field_release:xla.SessionComputation.computation_handle)
  
  ::xla::ComputationHandle* temp = computation_handle_;
  computation_handle_ = NULL;
  return temp;
}
inline ::xla::ComputationHandle* SessionComputation::mutable_computation_handle() {
  
  if (computation_handle_ == NULL) {
    computation_handle_ = ::google::protobuf::Arena::CreateMessage< ::xla::ComputationHandle >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:xla.SessionComputation.computation_handle)
  return computation_handle_;
}
inline void SessionComputation::set_allocated_computation_handle(::xla::ComputationHandle* computation_handle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(computation_handle_);
  }
  if (computation_handle) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(computation_handle)->GetArena();
    if (message_arena != submessage_arena) {
      computation_handle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, computation_handle, submessage_arena);
    }
    
  } else {
    
  }
  computation_handle_ = computation_handle;
  // @@protoc_insertion_point(field_set_allocated:xla.SessionComputation.computation_handle)
}

// map<int64, .xla.OperationRequest> requests = 3;
inline int SessionComputation::requests_size() const {
  return requests_.size();
}
inline void SessionComputation::clear_requests() {
  requests_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::int64, ::xla::OperationRequest >&
SessionComputation::requests() const {
  // @@protoc_insertion_point(field_map:xla.SessionComputation.requests)
  return requests_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::int64, ::xla::OperationRequest >*
SessionComputation::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_map:xla.SessionComputation.requests)
  return requests_.MutableMap();
}

// -------------------------------------------------------------------

// SessionModule

// .xla.SessionComputation entry = 1;
inline bool SessionModule::has_entry() const {
  return this != internal_default_instance() && entry_ != NULL;
}
inline void SessionModule::clear_entry() {
  if (GetArenaNoVirtual() == NULL && entry_ != NULL) {
    delete entry_;
  }
  entry_ = NULL;
}
inline const ::xla::SessionComputation& SessionModule::entry() const {
  const ::xla::SessionComputation* p = entry_;
  // @@protoc_insertion_point(field_get:xla.SessionModule.entry)
  return p != NULL ? *p : *reinterpret_cast<const ::xla::SessionComputation*>(
      &::xla::_SessionComputation_default_instance_);
}
inline ::xla::SessionComputation* SessionModule::release_entry() {
  // @@protoc_insertion_point(field_release:xla.SessionModule.entry)
  
  ::xla::SessionComputation* temp = entry_;
  entry_ = NULL;
  return temp;
}
inline ::xla::SessionComputation* SessionModule::mutable_entry() {
  
  if (entry_ == NULL) {
    entry_ = ::google::protobuf::Arena::Create< ::xla::SessionComputation >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:xla.SessionModule.entry)
  return entry_;
}
inline void SessionModule::set_allocated_entry(::xla::SessionComputation* entry) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete entry_;
  }
  if (entry) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      entry = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, entry, submessage_arena);
    }
    
  } else {
    
  }
  entry_ = entry;
  // @@protoc_insertion_point(field_set_allocated:xla.SessionModule.entry)
}

// repeated .xla.SessionComputation embedded_computations = 2;
inline int SessionModule::embedded_computations_size() const {
  return embedded_computations_.size();
}
inline void SessionModule::clear_embedded_computations() {
  embedded_computations_.Clear();
}
inline ::xla::SessionComputation* SessionModule::mutable_embedded_computations(int index) {
  // @@protoc_insertion_point(field_mutable:xla.SessionModule.embedded_computations)
  return embedded_computations_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::xla::SessionComputation >*
SessionModule::mutable_embedded_computations() {
  // @@protoc_insertion_point(field_mutable_list:xla.SessionModule.embedded_computations)
  return &embedded_computations_;
}
inline const ::xla::SessionComputation& SessionModule::embedded_computations(int index) const {
  // @@protoc_insertion_point(field_get:xla.SessionModule.embedded_computations)
  return embedded_computations_.Get(index);
}
inline ::xla::SessionComputation* SessionModule::add_embedded_computations() {
  // @@protoc_insertion_point(field_add:xla.SessionModule.embedded_computations)
  return embedded_computations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xla::SessionComputation >&
SessionModule::embedded_computations() const {
  // @@protoc_insertion_point(field_list:xla.SessionModule.embedded_computations)
  return embedded_computations_;
}

// repeated .xla.LiteralProto arguments = 3;
inline int SessionModule::arguments_size() const {
  return arguments_.size();
}
inline ::xla::LiteralProto* SessionModule::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:xla.SessionModule.arguments)
  return arguments_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::xla::LiteralProto >*
SessionModule::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:xla.SessionModule.arguments)
  return &arguments_;
}
inline const ::xla::LiteralProto& SessionModule::arguments(int index) const {
  // @@protoc_insertion_point(field_get:xla.SessionModule.arguments)
  return arguments_.Get(index);
}
inline ::xla::LiteralProto* SessionModule::add_arguments() {
  // @@protoc_insertion_point(field_add:xla.SessionModule.arguments)
  return arguments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xla::LiteralProto >&
SessionModule::arguments() const {
  // @@protoc_insertion_point(field_list:xla.SessionModule.arguments)
  return arguments_;
}

// .xla.LiteralProto result = 4;
inline bool SessionModule::has_result() const {
  return this != internal_default_instance() && result_ != NULL;
}
inline const ::xla::LiteralProto& SessionModule::result() const {
  const ::xla::LiteralProto* p = result_;
  // @@protoc_insertion_point(field_get:xla.SessionModule.result)
  return p != NULL ? *p : *reinterpret_cast<const ::xla::LiteralProto*>(
      &::xla::_LiteralProto_default_instance_);
}
inline ::xla::LiteralProto* SessionModule::release_result() {
  // @@protoc_insertion_point(field_release:xla.SessionModule.result)
  
  ::xla::LiteralProto* temp = result_;
  result_ = NULL;
  return temp;
}
inline ::xla::LiteralProto* SessionModule::mutable_result() {
  
  if (result_ == NULL) {
    result_ = ::google::protobuf::Arena::CreateMessage< ::xla::LiteralProto >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:xla.SessionModule.result)
  return result_;
}
inline void SessionModule::set_allocated_result(::xla::LiteralProto* result) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(result_);
  }
  if (result) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(result)->GetArena();
    if (message_arena != submessage_arena) {
      result = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:xla.SessionModule.result)
}

// string execution_platform = 5;
inline void SessionModule::clear_execution_platform() {
  execution_platform_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SessionModule::execution_platform() const {
  // @@protoc_insertion_point(field_get:xla.SessionModule.execution_platform)
  return execution_platform_.GetNoArena();
}
inline void SessionModule::set_execution_platform(const ::std::string& value) {
  
  execution_platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xla.SessionModule.execution_platform)
}
#if LANG_CXX11
inline void SessionModule::set_execution_platform(::std::string&& value) {
  
  execution_platform_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xla.SessionModule.execution_platform)
}
#endif
inline void SessionModule::set_execution_platform(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  execution_platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xla.SessionModule.execution_platform)
}
inline void SessionModule::set_execution_platform(const char* value, size_t size) {
  
  execution_platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xla.SessionModule.execution_platform)
}
inline ::std::string* SessionModule::mutable_execution_platform() {
  
  // @@protoc_insertion_point(field_mutable:xla.SessionModule.execution_platform)
  return execution_platform_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SessionModule::release_execution_platform() {
  // @@protoc_insertion_point(field_release:xla.SessionModule.execution_platform)
  
  return execution_platform_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionModule::set_allocated_execution_platform(::std::string* execution_platform) {
  if (execution_platform != NULL) {
    
  } else {
    
  }
  execution_platform_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), execution_platform);
  // @@protoc_insertion_point(field_set_allocated:xla.SessionModule.execution_platform)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace xla

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tensorflow_2fcompiler_2fxla_2fservice_2fsession_2eproto_INCLUDED
